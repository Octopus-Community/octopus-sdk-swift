// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: com/octopuscommunity/UserServiceProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Com_Octopuscommunity_DeleteUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeleteUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_GetGuestJwtRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_GetGuestJwtResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_GetGuestJwtResponse.OneOf_Result? = nil

  /// The response if authentication was successful.
  public var success: Com_Octopuscommunity_GetGuestJwtResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_GetGuestJwtResponse.Success()
    }
    set {result = .success(newValue)}
  }

  /// Error details if authentication failed.
  public var fail: Com_Octopuscommunity_GetGuestJwtResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_GetGuestJwtResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    /// The response if authentication was successful.
    case success(Com_Octopuscommunity_GetGuestJwtResponse.Success)
    /// Error details if authentication failed.
    case fail(Com_Octopuscommunity_GetGuestJwtResponse.Fail)

  }

  public enum ErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// An unknown error occurred.
    case unknownError // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownError
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownError: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Com_Octopuscommunity_GetGuestJwtResponse.ErrorCode] = [
      .unknownError,
    ]

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The jwt related to the user
    public var jwt: String = String()

    /// The user id
    public var userID: String = String()

    /// The profile of the user
    public var profile: Com_Octopuscommunity_PrivateProfile {
      get {return _profile ?? Com_Octopuscommunity_PrivateProfile()}
      set {_profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return self._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {self._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _profile: Com_Octopuscommunity_PrivateProfile? = nil
  }

  /// Detailed error information.
  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_GetGuestJwtResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The specific error code.
    public var errorCode: Com_Octopuscommunity_GetGuestJwtResponse.ErrorCode = .unknownError

    /// A human-readable error message.
    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Com_Octopuscommunity_GetJwtFromClientSignedTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clientToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.OneOf_Result? = nil

  /// The response if authentication was successful.
  public var success: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Success()
    }
    set {result = .success(newValue)}
  }

  /// Error details if authentication failed.
  public var fail: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    /// The response if authentication was successful.
    case success(Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Success)
    /// Error details if authentication failed.
    case fail(Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Fail)

  }

  public enum ErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// An unknown error occurred.
    case unknownError // = 0
    case userBanned // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownError
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownError
      case 1: self = .userBanned
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownError: return 0
      case .userBanned: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.ErrorCode] = [
      .unknownError,
      .userBanned,
    ]

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The jwt related to the user
    public var jwt: String = String()

    /// The user id
    public var userID: String = String()

    /// The profile of the user
    public var profile: Com_Octopuscommunity_PrivateProfile {
      get {return _profile ?? Com_Octopuscommunity_PrivateProfile()}
      set {_profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return self._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {self._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _profile: Com_Octopuscommunity_PrivateProfile? = nil
  }

  /// Detailed error information.
  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The specific error code.
    public var errorCode: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.ErrorCode = .unknownError

    /// A human-readable error message.
    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

///Only accessible to BO user
public struct Com_Octopuscommunity_CreateUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_CreateUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_CreateUserResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_CreateUserResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_CreateUserResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_CreateUserResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_CreateUserResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_CreateUserResponse.Success)
    case fail(Com_Octopuscommunity_CreateUserResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_CreateUserResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///TODO handle i18n. With error code ?
    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Com_Octopuscommunity_UpdateProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var update: Com_Octopuscommunity_ProfileUpdate {
    get {return _update ?? Com_Octopuscommunity_ProfileUpdate()}
    set {_update = newValue}
  }
  /// Returns true if `update` has been explicitly set.
  public var hasUpdate: Bool {return self._update != nil}
  /// Clears the value of `update`. Subsequent reads from it will return its default value.
  public mutating func clearUpdate() {self._update = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _update: Com_Octopuscommunity_ProfileUpdate? = nil
}

public struct Com_Octopuscommunity_ProfileUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///If a field is not set, it means that the user does not want to update it
  public var email: String {
    get {return _email ?? String()}
    set {_email = newValue}
  }
  /// Returns true if `email` has been explicitly set.
  public var hasEmail: Bool {return self._email != nil}
  /// Clears the value of `email`. Subsequent reads from it will return its default value.
  public mutating func clearEmail() {self._email = nil}

  public var nickname: String {
    get {return _nickname ?? String()}
    set {_nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  public var hasNickname: Bool {return self._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  public mutating func clearNickname() {self._nickname = nil}

  public var picture: Com_Octopuscommunity_PictureUpdateRequest {
    get {return _picture ?? Com_Octopuscommunity_PictureUpdateRequest()}
    set {_picture = newValue}
  }
  /// Returns true if `picture` has been explicitly set.
  public var hasPicture: Bool {return self._picture != nil}
  /// Clears the value of `picture`. Subsequent reads from it will return its default value.
  public mutating func clearPicture() {self._picture = nil}

  public var bio: String {
    get {return _bio ?? String()}
    set {_bio = newValue}
  }
  /// Returns true if `bio` has been explicitly set.
  public var hasBio: Bool {return self._bio != nil}
  /// Clears the value of `bio`. Subsequent reads from it will return its default value.
  public mutating func clearBio() {self._bio = nil}

  public var hasSeenOnboarding_p: Bool {
    get {return _hasSeenOnboarding_p ?? false}
    set {_hasSeenOnboarding_p = newValue}
  }
  /// Returns true if `hasSeenOnboarding_p` has been explicitly set.
  public var hasHasSeenOnboarding_p: Bool {return self._hasSeenOnboarding_p != nil}
  /// Clears the value of `hasSeenOnboarding_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasSeenOnboarding_p() {self._hasSeenOnboarding_p = nil}

  public var hasAcceptedCgu_p: Bool {
    get {return _hasAcceptedCgu_p ?? false}
    set {_hasAcceptedCgu_p = newValue}
  }
  /// Returns true if `hasAcceptedCgu_p` has been explicitly set.
  public var hasHasAcceptedCgu_p: Bool {return self._hasAcceptedCgu_p != nil}
  /// Clears the value of `hasAcceptedCgu_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasAcceptedCgu_p() {self._hasAcceptedCgu_p = nil}

  public var hasConfirmedNickname_p: Bool {
    get {return _hasConfirmedNickname_p ?? false}
    set {_hasConfirmedNickname_p = newValue}
  }
  /// Returns true if `hasConfirmedNickname_p` has been explicitly set.
  public var hasHasConfirmedNickname_p: Bool {return self._hasConfirmedNickname_p != nil}
  /// Clears the value of `hasConfirmedNickname_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasConfirmedNickname_p() {self._hasConfirmedNickname_p = nil}

  public var hasConfirmedBio_p: Bool {
    get {return _hasConfirmedBio_p ?? false}
    set {_hasConfirmedBio_p = newValue}
  }
  /// Returns true if `hasConfirmedBio_p` has been explicitly set.
  public var hasHasConfirmedBio_p: Bool {return self._hasConfirmedBio_p != nil}
  /// Clears the value of `hasConfirmedBio_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasConfirmedBio_p() {self._hasConfirmedBio_p = nil}

  public var hasConfirmedPicture_p: Bool {
    get {return _hasConfirmedPicture_p ?? false}
    set {_hasConfirmedPicture_p = newValue}
  }
  /// Returns true if `hasConfirmedPicture_p` has been explicitly set.
  public var hasHasConfirmedPicture_p: Bool {return self._hasConfirmedPicture_p != nil}
  /// Clears the value of `hasConfirmedPicture_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasConfirmedPicture_p() {self._hasConfirmedPicture_p = nil}

  ///true -> use an algorithm to generate an available nickname if non provided, are already taken
  ///false -> do not generate a nickname, just return an error if the provided nickname is already taken
  public var optFindAvailableNickname: Bool {
    get {return _optFindAvailableNickname ?? false}
    set {_optFindAvailableNickname = newValue}
  }
  /// Returns true if `optFindAvailableNickname` has been explicitly set.
  public var hasOptFindAvailableNickname: Bool {return self._optFindAvailableNickname != nil}
  /// Clears the value of `optFindAvailableNickname`. Subsequent reads from it will return its default value.
  public mutating func clearOptFindAvailableNickname() {self._optFindAvailableNickname = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _email: String? = nil
  fileprivate var _nickname: String? = nil
  fileprivate var _picture: Com_Octopuscommunity_PictureUpdateRequest? = nil
  fileprivate var _bio: String? = nil
  fileprivate var _hasSeenOnboarding_p: Bool? = nil
  fileprivate var _hasAcceptedCgu_p: Bool? = nil
  fileprivate var _hasConfirmedNickname_p: Bool? = nil
  fileprivate var _hasConfirmedBio_p: Bool? = nil
  fileprivate var _hasConfirmedPicture_p: Bool? = nil
  fileprivate var _optFindAvailableNickname: Bool? = nil
}

public struct Com_Octopuscommunity_PictureUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Com_Octopuscommunity_PictureUpdateRequest.OneOf_Request? = nil

  public var new: Com_Octopuscommunity_PictureUploadRequest {
    get {
      if case .new(let v)? = request {return v}
      return Com_Octopuscommunity_PictureUploadRequest()
    }
    set {request = .new(newValue)}
  }

  public var delete: Com_Octopuscommunity_PictureDeleteRequest {
    get {
      if case .delete(let v)? = request {return v}
      return Com_Octopuscommunity_PictureDeleteRequest()
    }
    set {request = .delete(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case new(Com_Octopuscommunity_PictureUploadRequest)
    case delete(Com_Octopuscommunity_PictureDeleteRequest)

  }

  public init() {}
}

public struct Com_Octopuscommunity_PictureUploadRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var file: Data = Data()

  ///True if sdk resized the file before uploading it. Skip backend resize process if true
  public var isOptimized: Bool {
    get {return _isOptimized ?? false}
    set {_isOptimized = newValue}
  }
  /// Returns true if `isOptimized` has been explicitly set.
  public var hasIsOptimized: Bool {return self._isOptimized != nil}
  /// Clears the value of `isOptimized`. Subsequent reads from it will return its default value.
  public mutating func clearIsOptimized() {self._isOptimized = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _isOptimized: Bool? = nil
}

public struct Com_Octopuscommunity_PictureDeleteRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///error GRPC status:
/// - PERMISSION_DENIED:
///            - "You can only update your own profile" ->  you can also do it as octopus admin
/// - NOT_FOUND:
///            - "User not found" -> the user you are trying to update does not exist
public struct Com_Octopuscommunity_UpdateProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_UpdateProfileResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_UpdateProfileResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_UpdateProfileResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_UpdateProfileResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_UpdateProfileResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_UpdateProfileResponse.Success)
    case fail(Com_Octopuscommunity_UpdateProfileResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var profile: Com_Octopuscommunity_PrivateProfile {
      get {return _profile ?? Com_Octopuscommunity_PrivateProfile()}
      set {_profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return self._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {self._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _profile: Com_Octopuscommunity_PrivateProfile? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_UpdateProfileResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///TODO handle i18n. With error code ?
    public var message: String = String()

    public var field: Com_Octopuscommunity_UpdateProfileResponse.Error.Field = .unknown

    public var details: Com_Octopuscommunity_UpdateProfileResponse.Error.OneOf_Details? = nil

    public var bannedWordUsed: Com_Octopuscommunity_UpdateProfileResponse.Error.BannedWordUsed {
      get {
        if case .bannedWordUsed(let v)? = details {return v}
        return Com_Octopuscommunity_UpdateProfileResponse.Error.BannedWordUsed()
      }
      set {details = .bannedWordUsed(newValue)}
    }

    public var alreadyTaken: Com_Octopuscommunity_UpdateProfileResponse.Error.AlreadyTaken {
      get {
        if case .alreadyTaken(let v)? = details {return v}
        return Com_Octopuscommunity_UpdateProfileResponse.Error.AlreadyTaken()
      }
      set {details = .alreadyTaken(newValue)}
    }

    public var badFormat: Com_Octopuscommunity_UpdateProfileResponse.Error.BadFormat {
      get {
        if case .badFormat(let v)? = details {return v}
        return Com_Octopuscommunity_UpdateProfileResponse.Error.BadFormat()
      }
      set {details = .badFormat(newValue)}
    }

    public var emptyFile: Com_Octopuscommunity_UpdateProfileResponse.Error.EmptyFile {
      get {
        if case .emptyFile(let v)? = details {return v}
        return Com_Octopuscommunity_UpdateProfileResponse.Error.EmptyFile()
      }
      set {details = .emptyFile(newValue)}
    }

    public var fileSizeTooBig: Com_Octopuscommunity_UpdateProfileResponse.Error.FileSizeTooBig {
      get {
        if case .fileSizeTooBig(let v)? = details {return v}
        return Com_Octopuscommunity_UpdateProfileResponse.Error.FileSizeTooBig()
      }
      set {details = .fileSizeTooBig(newValue)}
    }

    public var badFileFormat: Com_Octopuscommunity_UpdateProfileResponse.Error.BadFileFormat {
      get {
        if case .badFileFormat(let v)? = details {return v}
        return Com_Octopuscommunity_UpdateProfileResponse.Error.BadFileFormat()
      }
      set {details = .badFileFormat(newValue)}
    }

    public var uploadIssue: Com_Octopuscommunity_UpdateProfileResponse.Error.UploadIssue {
      get {
        if case .uploadIssue(let v)? = details {return v}
        return Com_Octopuscommunity_UpdateProfileResponse.Error.UploadIssue()
      }
      set {details = .uploadIssue(newValue)}
    }

    public var charLimitReached: Com_Octopuscommunity_UpdateProfileResponse.Error.CharLimitReached {
      get {
        if case .charLimitReached(let v)? = details {return v}
        return Com_Octopuscommunity_UpdateProfileResponse.Error.CharLimitReached()
      }
      set {details = .charLimitReached(newValue)}
    }

    public var moderatedContent: Com_Octopuscommunity_UpdateProfileResponse.Error.ModeratedContent {
      get {
        if case .moderatedContent(let v)? = details {return v}
        return Com_Octopuscommunity_UpdateProfileResponse.Error.ModeratedContent()
      }
      set {details = .moderatedContent(newValue)}
    }

    public var avatarInProcess: Com_Octopuscommunity_UpdateProfileResponse.Error.AvatarInProcess {
      get {
        if case .avatarInProcess(let v)? = details {return v}
        return Com_Octopuscommunity_UpdateProfileResponse.Error.AvatarInProcess()
      }
      set {details = .avatarInProcess(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case bannedWordUsed(Com_Octopuscommunity_UpdateProfileResponse.Error.BannedWordUsed)
      case alreadyTaken(Com_Octopuscommunity_UpdateProfileResponse.Error.AlreadyTaken)
      case badFormat(Com_Octopuscommunity_UpdateProfileResponse.Error.BadFormat)
      case emptyFile(Com_Octopuscommunity_UpdateProfileResponse.Error.EmptyFile)
      case fileSizeTooBig(Com_Octopuscommunity_UpdateProfileResponse.Error.FileSizeTooBig)
      case badFileFormat(Com_Octopuscommunity_UpdateProfileResponse.Error.BadFileFormat)
      case uploadIssue(Com_Octopuscommunity_UpdateProfileResponse.Error.UploadIssue)
      case charLimitReached(Com_Octopuscommunity_UpdateProfileResponse.Error.CharLimitReached)
      case moderatedContent(Com_Octopuscommunity_UpdateProfileResponse.Error.ModeratedContent)
      case avatarInProcess(Com_Octopuscommunity_UpdateProfileResponse.Error.AvatarInProcess)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///ModeratedContent
      case unknown // = 0

      ///AlreadyTaken, BadFormat, BannedWordUsed
      case email // = 1

      ///AlreadyTaken, BannedWordUsed, CharLimitReached, BadFormat, ModeratedContent
      case nickname // = 2

      ///EmptyFile, FileSizeTooBig, BadFileFormat, UploadIssue, AvatarInProcess
      case profilePicture // = 3

      ///BannedWordUsed, CharLimitReached, ModeratedContent
      case bio // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .email
        case 2: self = .nickname
        case 3: self = .profilePicture
        case 4: self = .bio
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .email: return 1
        case .nickname: return 2
        case .profilePicture: return 3
        case .bio: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_UpdateProfileResponse.Error.Field] = [
        .unknown,
        .email,
        .nickname,
        .profilePicture,
        .bio,
      ]

    }

    public struct BannedWordUsed: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var words: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct BadFormat: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct AlreadyTaken: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct EmptyFile: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct FileSizeTooBig: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct BadFileFormat: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct UploadIssue: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct CharLimitReached: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct ModeratedContent: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct AvatarInProcess: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

public struct Com_Octopuscommunity_GetPublicProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_GetPublicProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var profile: Com_Octopuscommunity_PublicProfile {
    get {return _profile ?? Com_Octopuscommunity_PublicProfile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {self._profile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _profile: Com_Octopuscommunity_PublicProfile? = nil
}

public struct Com_Octopuscommunity_PublicProfile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var nickname: String {
    get {return _nickname ?? String()}
    set {_nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  public var hasNickname: Bool {return self._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  public mutating func clearNickname() {self._nickname = nil}

  public var pictureURL: String {
    get {return _pictureURL ?? String()}
    set {_pictureURL = newValue}
  }
  /// Returns true if `pictureURL` has been explicitly set.
  public var hasPictureURL: Bool {return self._pictureURL != nil}
  /// Clears the value of `pictureURL`. Subsequent reads from it will return its default value.
  public mutating func clearPictureURL() {self._pictureURL = nil}

  public var bio: String {
    get {return _bio ?? String()}
    set {_bio = newValue}
  }
  /// Returns true if `bio` has been explicitly set.
  public var hasBio: Bool {return self._bio != nil}
  /// Clears the value of `bio`. Subsequent reads from it will return its default value.
  public mutating func clearBio() {self._bio = nil}

  public var descPostFeedID: String = String()

  public var ascPostFeedID: String = String()

  public var tags: [Com_Octopuscommunity_ProfileTag] = []

  ///JSON string
  public var metadata: String {
    get {return _metadata ?? String()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nickname: String? = nil
  fileprivate var _pictureURL: String? = nil
  fileprivate var _bio: String? = nil
  fileprivate var _metadata: String? = nil
}

public struct Com_Octopuscommunity_GetPrivateProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var fetchUserBlockList: Bool {
    get {return _fetchUserBlockList ?? false}
    set {_fetchUserBlockList = newValue}
  }
  /// Returns true if `fetchUserBlockList` has been explicitly set.
  public var hasFetchUserBlockList: Bool {return self._fetchUserBlockList != nil}
  /// Clears the value of `fetchUserBlockList`. Subsequent reads from it will return its default value.
  public mutating func clearFetchUserBlockList() {self._fetchUserBlockList = nil}

  ///Default to false
  public var fetchNotificationsBadge: Bool {
    get {return _fetchNotificationsBadge ?? false}
    set {_fetchNotificationsBadge = newValue}
  }
  /// Returns true if `fetchNotificationsBadge` has been explicitly set.
  public var hasFetchNotificationsBadge: Bool {return self._fetchNotificationsBadge != nil}
  /// Clears the value of `fetchNotificationsBadge`. Subsequent reads from it will return its default value.
  public mutating func clearFetchNotificationsBadge() {self._fetchNotificationsBadge = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fetchUserBlockList: Bool? = nil
  fileprivate var _fetchNotificationsBadge: Bool? = nil
}

///May throw NOT_FOUND if the user does not exist, or you do not have the right to see the profile
public struct Com_Octopuscommunity_GetPrivateProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var profile: Com_Octopuscommunity_PrivateProfile {
    get {return _profile ?? Com_Octopuscommunity_PrivateProfile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {self._profile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _profile: Com_Octopuscommunity_PrivateProfile? = nil
}

public struct Com_Octopuscommunity_PrivateProfile: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var email: String {
    get {return _storage._email ?? String()}
    set {_uniqueStorage()._email = newValue}
  }
  /// Returns true if `email` has been explicitly set.
  public var hasEmail: Bool {return _storage._email != nil}
  /// Clears the value of `email`. Subsequent reads from it will return its default value.
  public mutating func clearEmail() {_uniqueStorage()._email = nil}

  public var nickname: String {
    get {return _storage._nickname ?? String()}
    set {_uniqueStorage()._nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  public var hasNickname: Bool {return _storage._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  public mutating func clearNickname() {_uniqueStorage()._nickname = nil}

  public var pictureURL: String {
    get {return _storage._pictureURL ?? String()}
    set {_uniqueStorage()._pictureURL = newValue}
  }
  /// Returns true if `pictureURL` has been explicitly set.
  public var hasPictureURL: Bool {return _storage._pictureURL != nil}
  /// Clears the value of `pictureURL`. Subsequent reads from it will return its default value.
  public mutating func clearPictureURL() {_uniqueStorage()._pictureURL = nil}

  public var bio: String {
    get {return _storage._bio ?? String()}
    set {_uniqueStorage()._bio = newValue}
  }
  /// Returns true if `bio` has been explicitly set.
  public var hasBio: Bool {return _storage._bio != nil}
  /// Clears the value of `bio`. Subsequent reads from it will return its default value.
  public mutating func clearBio() {_uniqueStorage()._bio = nil}

  public var hasSeenOnboarding_p: Bool {
    get {return _storage._hasSeenOnboarding_p ?? false}
    set {_uniqueStorage()._hasSeenOnboarding_p = newValue}
  }
  /// Returns true if `hasSeenOnboarding_p` has been explicitly set.
  public var hasHasSeenOnboarding_p: Bool {return _storage._hasSeenOnboarding_p != nil}
  /// Clears the value of `hasSeenOnboarding_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasSeenOnboarding_p() {_uniqueStorage()._hasSeenOnboarding_p = nil}

  public var hasAcceptedCgu_p: Bool {
    get {return _storage._hasAcceptedCgu_p ?? false}
    set {_uniqueStorage()._hasAcceptedCgu_p = newValue}
  }
  /// Returns true if `hasAcceptedCgu_p` has been explicitly set.
  public var hasHasAcceptedCgu_p: Bool {return _storage._hasAcceptedCgu_p != nil}
  /// Clears the value of `hasAcceptedCgu_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasAcceptedCgu_p() {_uniqueStorage()._hasAcceptedCgu_p = nil}

  public var hasConfirmedNickname_p: Bool {
    get {return _storage._hasConfirmedNickname_p ?? false}
    set {_uniqueStorage()._hasConfirmedNickname_p = newValue}
  }
  /// Returns true if `hasConfirmedNickname_p` has been explicitly set.
  public var hasHasConfirmedNickname_p: Bool {return _storage._hasConfirmedNickname_p != nil}
  /// Clears the value of `hasConfirmedNickname_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasConfirmedNickname_p() {_uniqueStorage()._hasConfirmedNickname_p = nil}

  public var hasConfirmedPicture_p: Bool {
    get {return _storage._hasConfirmedPicture_p ?? false}
    set {_uniqueStorage()._hasConfirmedPicture_p = newValue}
  }
  /// Returns true if `hasConfirmedPicture_p` has been explicitly set.
  public var hasHasConfirmedPicture_p: Bool {return _storage._hasConfirmedPicture_p != nil}
  /// Clears the value of `hasConfirmedPicture_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasConfirmedPicture_p() {_uniqueStorage()._hasConfirmedPicture_p = nil}

  public var hasConfirmedBio_p: Bool {
    get {return _storage._hasConfirmedBio_p ?? false}
    set {_uniqueStorage()._hasConfirmedBio_p = newValue}
  }
  /// Returns true if `hasConfirmedBio_p` has been explicitly set.
  public var hasHasConfirmedBio_p: Bool {return _storage._hasConfirmedBio_p != nil}
  /// Clears the value of `hasConfirmedBio_p`. Subsequent reads from it will return its default value.
  public mutating func clearHasConfirmedBio_p() {_uniqueStorage()._hasConfirmedBio_p = nil}

  public var isGuest: Bool {
    get {return _storage._isGuest}
    set {_uniqueStorage()._isGuest = newValue}
  }

  public var descPostFeedID: String {
    get {return _storage._descPostFeedID}
    set {_uniqueStorage()._descPostFeedID = newValue}
  }

  public var ascPostFeedID: String {
    get {return _storage._ascPostFeedID}
    set {_uniqueStorage()._ascPostFeedID = newValue}
  }

  ///If nickname is present, but originalNickname is not. It means that nickname is the original one.
  public var originalNickname: String {
    get {return _storage._originalNickname ?? String()}
    set {_uniqueStorage()._originalNickname = newValue}
  }
  /// Returns true if `originalNickname` has been explicitly set.
  public var hasOriginalNickname: Bool {return _storage._originalNickname != nil}
  /// Clears the value of `originalNickname`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalNickname() {_uniqueStorage()._originalNickname = nil}

  public var notSeenNotificationsCount: UInt32 {
    get {return _storage._notSeenNotificationsCount ?? 0}
    set {_uniqueStorage()._notSeenNotificationsCount = newValue}
  }
  /// Returns true if `notSeenNotificationsCount` has been explicitly set.
  public var hasNotSeenNotificationsCount: Bool {return _storage._notSeenNotificationsCount != nil}
  /// Clears the value of `notSeenNotificationsCount`. Subsequent reads from it will return its default value.
  public mutating func clearNotSeenNotificationsCount() {_uniqueStorage()._notSeenNotificationsCount = nil}

  public var tags: [Com_Octopuscommunity_ProfileTag] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var usersBlockList: [String] {
    get {return _storage._usersBlockList}
    set {_uniqueStorage()._usersBlockList = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Com_Octopuscommunity_BanUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var reasons: [Com_Octopuscommunity_StatusReasonCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_BanUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_UnbanUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_UnbanUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ShadowBanUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ShadowBanUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ShadowUnbanUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_UnShadowBanUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeleteMyProfileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var reason: Com_Octopuscommunity_DeleteMyProfileRequest.DeleteMyProfileReason {
    get {return _reason ?? Com_Octopuscommunity_DeleteMyProfileRequest.DeleteMyProfileReason()}
    set {_reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  public var hasReason: Bool {return self._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  public mutating func clearReason() {self._reason = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DeleteMyProfileReasonCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecifiedDeleteReason // = 0

    /// Community content is no more interesting me
    case noMoreInterested // = 1

    /// Some key features are missing
    case missingKeyFeatures // = 2

    /// I am facing technical issues
    case technicalIssues // = 3

    /// I am worrying about confidentiality of my data
    case confidentialityWorrying // = 4

    /// I am not satisfied about moderation service or community quality
    case communityQuality // = 5

    /// I want to reduce my time spent on social networks
    case reducingSnTime // = 6

    /// Other
    case other // = 9999
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecifiedDeleteReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedDeleteReason
      case 1: self = .noMoreInterested
      case 2: self = .missingKeyFeatures
      case 3: self = .technicalIssues
      case 4: self = .confidentialityWorrying
      case 5: self = .communityQuality
      case 6: self = .reducingSnTime
      case 9999: self = .other
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecifiedDeleteReason: return 0
      case .noMoreInterested: return 1
      case .missingKeyFeatures: return 2
      case .technicalIssues: return 3
      case .confidentialityWorrying: return 4
      case .communityQuality: return 5
      case .reducingSnTime: return 6
      case .other: return 9999
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Com_Octopuscommunity_DeleteMyProfileRequest.DeleteMyProfileReasonCode] = [
      .unspecifiedDeleteReason,
      .noMoreInterested,
      .missingKeyFeatures,
      .technicalIssues,
      .confidentialityWorrying,
      .communityQuality,
      .reducingSnTime,
      .other,
    ]

  }

  public struct DeleteMyProfileReason: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///    optional string message = 2;  //Not used now
    public var code: Com_Octopuscommunity_DeleteMyProfileRequest.DeleteMyProfileReasonCode = .unspecifiedDeleteReason

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _reason: Com_Octopuscommunity_DeleteMyProfileRequest.DeleteMyProfileReason? = nil
}

public struct Com_Octopuscommunity_DeleteMyProfileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ReportUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var reasonCodes: [Com_Octopuscommunity_ReportReasonCode] = []

  public var customReason: String {
    get {return _customReason ?? String()}
    set {_customReason = newValue}
  }
  /// Returns true if `customReason` has been explicitly set.
  public var hasCustomReason: Bool {return self._customReason != nil}
  /// Clears the value of `customReason`. Subsequent reads from it will return its default value.
  public mutating func clearCustomReason() {self._customReason = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _customReason: String? = nil
}

public struct Com_Octopuscommunity_ReportUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_BlockUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_BlockUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ByPassAbTestingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  /// If true, the user will be provided access to the community. If false, it will be in the cohort of users who do not have access to the community.
  public var giveCommunityAccess: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ByPassAbTestingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_ByPassAbTestingResponse.OneOf_Result? = nil

  /// The response if abtesting score change was successful.
  public var success: Com_Octopuscommunity_ByPassAbTestingResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_ByPassAbTestingResponse.Success()
    }
    set {result = .success(newValue)}
  }

  /// Error details if abtesting score change failed.
  public var fail: Com_Octopuscommunity_ByPassAbTestingResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_ByPassAbTestingResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    /// The response if abtesting score change was successful.
    case success(Com_Octopuscommunity_ByPassAbTestingResponse.Success)
    /// Error details if abtesting score change failed.
    case fail(Com_Octopuscommunity_ByPassAbTestingResponse.Fail)

  }

  public enum ErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// An unknown error occurred.
    case unknownError // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownError
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownError: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Com_Octopuscommunity_ByPassAbTestingResponse.ErrorCode] = [
      .unknownError,
    ]

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The jwt related to the user, with the new abTesting score
    public var jwt: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Detailed error information.
  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_ByPassAbTestingResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The specific error code.
    public var errorCode: Com_Octopuscommunity_ByPassAbTestingResponse.ErrorCode = .unknownError

    /// A human-readable error message.
    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Com_Octopuscommunity_CanAccessCommunityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_CanAccessCommunityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var canAccessCommunity: Bool = false

  public var communityDisabledMessage: String {
    get {return _communityDisabledMessage ?? String()}
    set {_communityDisabledMessage = newValue}
  }
  /// Returns true if `communityDisabledMessage` has been explicitly set.
  public var hasCommunityDisabledMessage: Bool {return self._communityDisabledMessage != nil}
  /// Clears the value of `communityDisabledMessage`. Subsequent reads from it will return its default value.
  public mutating func clearCommunityDisabledMessage() {self._communityDisabledMessage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _communityDisabledMessage: String? = nil
}

public struct Com_Octopuscommunity_SearchUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var by: Com_Octopuscommunity_SearchUserRequest.OneOf_By? = nil

  public var userID: String {
    get {
      if case .userID(let v)? = by {return v}
      return String()
    }
    set {by = .userID(newValue)}
  }

  public var clientUserID: String {
    get {
      if case .clientUserID(let v)? = by {return v}
      return String()
    }
    set {by = .clientUserID(newValue)}
  }

  public var nickname: String {
    get {
      if case .nickname(let v)? = by {return v}
      return String()
    }
    set {by = .nickname(newValue)}
  }

  public var email: String {
    get {
      if case .email(let v)? = by {return v}
      return String()
    }
    set {by = .email(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_By: Equatable, Sendable {
    case userID(String)
    case clientUserID(String)
    case nickname(String)
    case email(String)

  }

  public init() {}
}

public struct Com_Octopuscommunity_SearchUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var profile: Com_Octopuscommunity_PublicProfile {
    get {return _profile ?? Com_Octopuscommunity_PublicProfile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {self._profile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _profile: Com_Octopuscommunity_PublicProfile? = nil
}

public struct Com_Octopuscommunity_SetProfileTagRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var tags: [Com_Octopuscommunity_ProfileTag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_SetProfileTagResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_SetProfileTagResponse.OneOf_Result? = nil

  /// The response profile tag setup was successful.
  public var success: Com_Octopuscommunity_SetProfileTagResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_SetProfileTagResponse.Success()
    }
    set {result = .success(newValue)}
  }

  /// Error details if profile tag setup failed.
  public var fail: Com_Octopuscommunity_SetProfileTagResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_SetProfileTagResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    /// The response profile tag setup was successful.
    case success(Com_Octopuscommunity_SetProfileTagResponse.Success)
    /// Error details if profile tag setup failed.
    case fail(Com_Octopuscommunity_SetProfileTagResponse.Fail)

  }

  public enum ErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// An unknown error occurred.
    case unknownError // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownError
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownError: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Com_Octopuscommunity_SetProfileTagResponse.ErrorCode] = [
      .unknownError,
    ]

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The public profile related to the user, with the new profile tag
    public var profile: Com_Octopuscommunity_PublicProfile {
      get {return _profile ?? Com_Octopuscommunity_PublicProfile()}
      set {_profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return self._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {self._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _profile: Com_Octopuscommunity_PublicProfile? = nil
  }

  /// Detailed error information.
  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_SetProfileTagResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The specific error code.
    public var errorCode: Com_Octopuscommunity_SetProfileTagResponse.ErrorCode = .unknownError

    /// A human-readable error message.
    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.octopuscommunity"

extension Com_Octopuscommunity_DeleteUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteUserRequest, rhs: Com_Octopuscommunity_DeleteUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteUserResponse, rhs: Com_Octopuscommunity_DeleteUserResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetGuestJwtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGuestJwtRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetGuestJwtRequest, rhs: Com_Octopuscommunity_GetGuestJwtRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetGuestJwtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGuestJwtResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_GetGuestJwtResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_GetGuestJwtResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetGuestJwtResponse, rhs: Com_Octopuscommunity_GetGuestJwtResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetGuestJwtResponse.ErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ERROR"),
  ]
}

extension Com_Octopuscommunity_GetGuestJwtResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_GetGuestJwtResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
    2: .same(proto: "userId"),
    3: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jwt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.jwt.isEmpty {
      try visitor.visitSingularStringField(value: self.jwt, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetGuestJwtResponse.Success, rhs: Com_Octopuscommunity_GetGuestJwtResponse.Success) -> Bool {
    if lhs.jwt != rhs.jwt {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetGuestJwtResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_GetGuestJwtResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetGuestJwtResponse.Fail, rhs: Com_Octopuscommunity_GetGuestJwtResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetGuestJwtResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_GetGuestJwtResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errorCode"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .unknownError {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetGuestJwtResponse.Error, rhs: Com_Octopuscommunity_GetGuestJwtResponse.Error) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetJwtFromClientSignedTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetJwtFromClientSignedTokenRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientToken"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientToken.isEmpty {
      try visitor.visitSingularStringField(value: self.clientToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetJwtFromClientSignedTokenRequest, rhs: Com_Octopuscommunity_GetJwtFromClientSignedTokenRequest) -> Bool {
    if lhs.clientToken != rhs.clientToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetJwtFromClientSignedTokenResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse, rhs: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.ErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ERROR"),
    1: .same(proto: "USER_BANNED"),
  ]
}

extension Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
    2: .same(proto: "userId"),
    3: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jwt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.jwt.isEmpty {
      try visitor.visitSingularStringField(value: self.jwt, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Success, rhs: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Success) -> Bool {
    if lhs.jwt != rhs.jwt {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Fail, rhs: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .unknownError {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Error, rhs: Com_Octopuscommunity_GetJwtFromClientSignedTokenResponse.Error) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_CreateUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_CreateUserRequest, rhs: Com_Octopuscommunity_CreateUserRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_CreateUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_CreateUserResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_CreateUserResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_CreateUserResponse, rhs: Com_Octopuscommunity_CreateUserResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_CreateUserResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_CreateUserResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_CreateUserResponse.Success, rhs: Com_Octopuscommunity_CreateUserResponse.Success) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_CreateUserResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_CreateUserResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_CreateUserResponse.Fail, rhs: Com_Octopuscommunity_CreateUserResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_CreateUserResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_CreateUserResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_CreateUserResponse.Error, rhs: Com_Octopuscommunity_CreateUserResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateProfileRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._update) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._update {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileRequest, rhs: Com_Octopuscommunity_UpdateProfileRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._update != rhs._update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ProfileUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfileUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "email"),
    3: .same(proto: "nickname"),
    4: .same(proto: "picture"),
    5: .same(proto: "bio"),
    6: .same(proto: "hasSeenOnboarding"),
    7: .same(proto: "hasAcceptedCgu"),
    8: .same(proto: "hasConfirmedNickname"),
    9: .same(proto: "hasConfirmedBio"),
    10: .same(proto: "hasConfirmedPicture"),
    11: .same(proto: "optFindAvailableNickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._email) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._nickname) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._picture) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._bio) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._hasSeenOnboarding_p) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._hasAcceptedCgu_p) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._hasConfirmedNickname_p) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._hasConfirmedBio_p) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._hasConfirmedPicture_p) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self._optFindAvailableNickname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._email {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._picture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._bio {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._hasSeenOnboarding_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._hasAcceptedCgu_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._hasConfirmedNickname_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._hasConfirmedBio_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._hasConfirmedPicture_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._optFindAvailableNickname {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ProfileUpdate, rhs: Com_Octopuscommunity_ProfileUpdate) -> Bool {
    if lhs._email != rhs._email {return false}
    if lhs._nickname != rhs._nickname {return false}
    if lhs._picture != rhs._picture {return false}
    if lhs._bio != rhs._bio {return false}
    if lhs._hasSeenOnboarding_p != rhs._hasSeenOnboarding_p {return false}
    if lhs._hasAcceptedCgu_p != rhs._hasAcceptedCgu_p {return false}
    if lhs._hasConfirmedNickname_p != rhs._hasConfirmedNickname_p {return false}
    if lhs._hasConfirmedBio_p != rhs._hasConfirmedBio_p {return false}
    if lhs._hasConfirmedPicture_p != rhs._hasConfirmedPicture_p {return false}
    if lhs._optFindAvailableNickname != rhs._optFindAvailableNickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PictureUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PictureUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "new"),
    2: .same(proto: "delete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_PictureUploadRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .new(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .new(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_PictureDeleteRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .new?: try {
      guard case .new(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PictureUpdateRequest, rhs: Com_Octopuscommunity_PictureUpdateRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PictureUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PictureUploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "file"),
    2: .same(proto: "isOptimized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.file) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isOptimized) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.file.isEmpty {
      try visitor.visitSingularBytesField(value: self.file, fieldNumber: 1)
    }
    try { if let v = self._isOptimized {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PictureUploadRequest, rhs: Com_Octopuscommunity_PictureUploadRequest) -> Bool {
    if lhs.file != rhs.file {return false}
    if lhs._isOptimized != rhs._isOptimized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PictureDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PictureDeleteRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PictureDeleteRequest, rhs: Com_Octopuscommunity_PictureDeleteRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateProfileResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse, rhs: Com_Octopuscommunity_UpdateProfileResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Success, rhs: Com_Octopuscommunity_UpdateProfileResponse.Success) -> Bool {
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Fail, rhs: Com_Octopuscommunity_UpdateProfileResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    101: .same(proto: "bannedWordUsed"),
    102: .same(proto: "alreadyTaken"),
    103: .same(proto: "badFormat"),
    104: .same(proto: "emptyFile"),
    105: .same(proto: "fileSizeTooBig"),
    106: .same(proto: "badFileFormat"),
    107: .same(proto: "uploadIssue"),
    108: .same(proto: "charLimitReached"),
    109: .same(proto: "moderatedContent"),
    110: .same(proto: "avatarInProcess"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.field) }()
      case 101: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Error.BannedWordUsed?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .bannedWordUsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .bannedWordUsed(v)
        }
      }()
      case 102: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Error.AlreadyTaken?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .alreadyTaken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .alreadyTaken(v)
        }
      }()
      case 103: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Error.BadFormat?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badFormat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badFormat(v)
        }
      }()
      case 104: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Error.EmptyFile?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyFile(v)
        }
      }()
      case 105: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Error.FileSizeTooBig?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .fileSizeTooBig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .fileSizeTooBig(v)
        }
      }()
      case 106: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Error.BadFileFormat?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badFileFormat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badFileFormat(v)
        }
      }()
      case 107: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Error.UploadIssue?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .uploadIssue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .uploadIssue(v)
        }
      }()
      case 108: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Error.CharLimitReached?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .charLimitReached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .charLimitReached(v)
        }
      }()
      case 109: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Error.ModeratedContent?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .moderatedContent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .moderatedContent(v)
        }
      }()
      case 110: try {
        var v: Com_Octopuscommunity_UpdateProfileResponse.Error.AvatarInProcess?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .avatarInProcess(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .avatarInProcess(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.field != .unknown {
      try visitor.visitSingularEnumField(value: self.field, fieldNumber: 2)
    }
    switch self.details {
    case .bannedWordUsed?: try {
      guard case .bannedWordUsed(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .alreadyTaken?: try {
      guard case .alreadyTaken(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .badFormat?: try {
      guard case .badFormat(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .emptyFile?: try {
      guard case .emptyFile(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .fileSizeTooBig?: try {
      guard case .fileSizeTooBig(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .badFileFormat?: try {
      guard case .badFileFormat(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .uploadIssue?: try {
      guard case .uploadIssue(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .charLimitReached?: try {
      guard case .charLimitReached(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .moderatedContent?: try {
      guard case .moderatedContent(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .avatarInProcess?: try {
      guard case .avatarInProcess(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.field != rhs.field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "EMAIL"),
    2: .same(proto: "NICKNAME"),
    3: .same(proto: "PROFILE_PICTURE"),
    4: .same(proto: "BIO"),
  ]
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.BannedWordUsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.Error.protoMessageName + ".BannedWordUsed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "words"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.words) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.words.isEmpty {
      try visitor.visitRepeatedStringField(value: self.words, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error.BannedWordUsed, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error.BannedWordUsed) -> Bool {
    if lhs.words != rhs.words {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.BadFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.Error.protoMessageName + ".BadFormat"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error.BadFormat, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error.BadFormat) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.AlreadyTaken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.Error.protoMessageName + ".AlreadyTaken"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error.AlreadyTaken, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error.AlreadyTaken) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.EmptyFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.Error.protoMessageName + ".EmptyFile"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error.EmptyFile, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error.EmptyFile) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.FileSizeTooBig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.Error.protoMessageName + ".FileSizeTooBig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error.FileSizeTooBig, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error.FileSizeTooBig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.BadFileFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.Error.protoMessageName + ".BadFileFormat"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error.BadFileFormat, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error.BadFileFormat) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.UploadIssue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.Error.protoMessageName + ".UploadIssue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error.UploadIssue, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error.UploadIssue) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.CharLimitReached: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.Error.protoMessageName + ".CharLimitReached"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error.CharLimitReached, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error.CharLimitReached) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.ModeratedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.Error.protoMessageName + ".ModeratedContent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error.ModeratedContent, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error.ModeratedContent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdateProfileResponse.Error.AvatarInProcess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdateProfileResponse.Error.protoMessageName + ".AvatarInProcess"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdateProfileResponse.Error.AvatarInProcess, rhs: Com_Octopuscommunity_UpdateProfileResponse.Error.AvatarInProcess) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetPublicProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPublicProfileRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetPublicProfileRequest, rhs: Com_Octopuscommunity_GetPublicProfileRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetPublicProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPublicProfileResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetPublicProfileResponse, rhs: Com_Octopuscommunity_GetPublicProfileResponse) -> Bool {
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PublicProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "nickname"),
    3: .same(proto: "pictureUrl"),
    4: .same(proto: "bio"),
    10: .same(proto: "descPostFeedId"),
    11: .same(proto: "ascPostFeedId"),
    20: .same(proto: "tags"),
    999: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nickname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._pictureURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._bio) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.descPostFeedID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.ascPostFeedID) }()
      case 20: try { try decoder.decodeRepeatedEnumField(value: &self.tags) }()
      case 999: try { try decoder.decodeSingularStringField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._nickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pictureURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bio {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.descPostFeedID.isEmpty {
      try visitor.visitSingularStringField(value: self.descPostFeedID, fieldNumber: 10)
    }
    if !self.ascPostFeedID.isEmpty {
      try visitor.visitSingularStringField(value: self.ascPostFeedID, fieldNumber: 11)
    }
    if !self.tags.isEmpty {
      try visitor.visitPackedEnumField(value: self.tags, fieldNumber: 20)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularStringField(value: v, fieldNumber: 999)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PublicProfile, rhs: Com_Octopuscommunity_PublicProfile) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._nickname != rhs._nickname {return false}
    if lhs._pictureURL != rhs._pictureURL {return false}
    if lhs._bio != rhs._bio {return false}
    if lhs.descPostFeedID != rhs.descPostFeedID {return false}
    if lhs.ascPostFeedID != rhs.ascPostFeedID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetPrivateProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPrivateProfileRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "fetchUserBlockList"),
    3: .same(proto: "fetchNotificationsBadge"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._fetchUserBlockList) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._fetchNotificationsBadge) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._fetchUserBlockList {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fetchNotificationsBadge {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetPrivateProfileRequest, rhs: Com_Octopuscommunity_GetPrivateProfileRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._fetchUserBlockList != rhs._fetchUserBlockList {return false}
    if lhs._fetchNotificationsBadge != rhs._fetchNotificationsBadge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetPrivateProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPrivateProfileResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetPrivateProfileResponse, rhs: Com_Octopuscommunity_GetPrivateProfileResponse) -> Bool {
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PrivateProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivateProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "email"),
    3: .same(proto: "nickname"),
    4: .same(proto: "pictureUrl"),
    5: .same(proto: "bio"),
    6: .same(proto: "hasSeenOnboarding"),
    7: .same(proto: "hasAcceptedCgu"),
    113: .same(proto: "hasConfirmedNickname"),
    114: .same(proto: "hasConfirmedPicture"),
    115: .same(proto: "hasConfirmedBio"),
    9: .same(proto: "isGuest"),
    10: .same(proto: "descPostFeedId"),
    11: .same(proto: "ascPostFeedId"),
    12: .same(proto: "originalNickname"),
    20: .same(proto: "notSeenNotificationsCount"),
    30: .same(proto: "tags"),
    100: .same(proto: "usersBlockList"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _email: String? = nil
    var _nickname: String? = nil
    var _pictureURL: String? = nil
    var _bio: String? = nil
    var _hasSeenOnboarding_p: Bool? = nil
    var _hasAcceptedCgu_p: Bool? = nil
    var _hasConfirmedNickname_p: Bool? = nil
    var _hasConfirmedPicture_p: Bool? = nil
    var _hasConfirmedBio_p: Bool? = nil
    var _isGuest: Bool = false
    var _descPostFeedID: String = String()
    var _ascPostFeedID: String = String()
    var _originalNickname: String? = nil
    var _notSeenNotificationsCount: UInt32? = nil
    var _tags: [Com_Octopuscommunity_ProfileTag] = []
    var _usersBlockList: [String] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _email = source._email
      _nickname = source._nickname
      _pictureURL = source._pictureURL
      _bio = source._bio
      _hasSeenOnboarding_p = source._hasSeenOnboarding_p
      _hasAcceptedCgu_p = source._hasAcceptedCgu_p
      _hasConfirmedNickname_p = source._hasConfirmedNickname_p
      _hasConfirmedPicture_p = source._hasConfirmedPicture_p
      _hasConfirmedBio_p = source._hasConfirmedBio_p
      _isGuest = source._isGuest
      _descPostFeedID = source._descPostFeedID
      _ascPostFeedID = source._ascPostFeedID
      _originalNickname = source._originalNickname
      _notSeenNotificationsCount = source._notSeenNotificationsCount
      _tags = source._tags
      _usersBlockList = source._usersBlockList
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._pictureURL) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._bio) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._hasSeenOnboarding_p) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._hasAcceptedCgu_p) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isGuest) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._descPostFeedID) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._ascPostFeedID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._originalNickname) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._notSeenNotificationsCount) }()
        case 30: try { try decoder.decodeRepeatedEnumField(value: &_storage._tags) }()
        case 100: try { try decoder.decodeRepeatedStringField(value: &_storage._usersBlockList) }()
        case 113: try { try decoder.decodeSingularBoolField(value: &_storage._hasConfirmedNickname_p) }()
        case 114: try { try decoder.decodeSingularBoolField(value: &_storage._hasConfirmedPicture_p) }()
        case 115: try { try decoder.decodeSingularBoolField(value: &_storage._hasConfirmedBio_p) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._email {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._nickname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._pictureURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._bio {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._hasSeenOnboarding_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._hasAcceptedCgu_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      if _storage._isGuest != false {
        try visitor.visitSingularBoolField(value: _storage._isGuest, fieldNumber: 9)
      }
      if !_storage._descPostFeedID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._descPostFeedID, fieldNumber: 10)
      }
      if !_storage._ascPostFeedID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ascPostFeedID, fieldNumber: 11)
      }
      try { if let v = _storage._originalNickname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._notSeenNotificationsCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 20)
      } }()
      if !_storage._tags.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._tags, fieldNumber: 30)
      }
      if !_storage._usersBlockList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._usersBlockList, fieldNumber: 100)
      }
      try { if let v = _storage._hasConfirmedNickname_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 113)
      } }()
      try { if let v = _storage._hasConfirmedPicture_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 114)
      } }()
      try { if let v = _storage._hasConfirmedBio_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 115)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PrivateProfile, rhs: Com_Octopuscommunity_PrivateProfile) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._pictureURL != rhs_storage._pictureURL {return false}
        if _storage._bio != rhs_storage._bio {return false}
        if _storage._hasSeenOnboarding_p != rhs_storage._hasSeenOnboarding_p {return false}
        if _storage._hasAcceptedCgu_p != rhs_storage._hasAcceptedCgu_p {return false}
        if _storage._hasConfirmedNickname_p != rhs_storage._hasConfirmedNickname_p {return false}
        if _storage._hasConfirmedPicture_p != rhs_storage._hasConfirmedPicture_p {return false}
        if _storage._hasConfirmedBio_p != rhs_storage._hasConfirmedBio_p {return false}
        if _storage._isGuest != rhs_storage._isGuest {return false}
        if _storage._descPostFeedID != rhs_storage._descPostFeedID {return false}
        if _storage._ascPostFeedID != rhs_storage._ascPostFeedID {return false}
        if _storage._originalNickname != rhs_storage._originalNickname {return false}
        if _storage._notSeenNotificationsCount != rhs_storage._notSeenNotificationsCount {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._usersBlockList != rhs_storage._usersBlockList {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_BanUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BanUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "reasons"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reasons) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.reasons.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasons, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_BanUserRequest, rhs: Com_Octopuscommunity_BanUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.reasons != rhs.reasons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_BanUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BanUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_BanUserResponse, rhs: Com_Octopuscommunity_BanUserResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UnbanUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnbanUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UnbanUserRequest, rhs: Com_Octopuscommunity_UnbanUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UnbanUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnbanUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UnbanUserResponse, rhs: Com_Octopuscommunity_UnbanUserResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ShadowBanUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShadowBanUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ShadowBanUserRequest, rhs: Com_Octopuscommunity_ShadowBanUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ShadowBanUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShadowBanUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ShadowBanUserResponse, rhs: Com_Octopuscommunity_ShadowBanUserResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ShadowUnbanUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShadowUnbanUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ShadowUnbanUserRequest, rhs: Com_Octopuscommunity_ShadowUnbanUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UnShadowBanUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnShadowBanUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UnShadowBanUserResponse, rhs: Com_Octopuscommunity_UnShadowBanUserResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteMyProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMyProfileRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._reason {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteMyProfileRequest, rhs: Com_Octopuscommunity_DeleteMyProfileRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteMyProfileRequest.DeleteMyProfileReasonCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_DELETE_REASON"),
    1: .same(proto: "NO_MORE_INTERESTED"),
    2: .same(proto: "MISSING_KEY_FEATURES"),
    3: .same(proto: "TECHNICAL_ISSUES"),
    4: .same(proto: "CONFIDENTIALITY_WORRYING"),
    5: .same(proto: "COMMUNITY_QUALITY"),
    6: .same(proto: "REDUCING_SN_TIME"),
    9999: .same(proto: "OTHER"),
  ]
}

extension Com_Octopuscommunity_DeleteMyProfileRequest.DeleteMyProfileReason: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_DeleteMyProfileRequest.protoMessageName + ".DeleteMyProfileReason"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unspecifiedDeleteReason {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteMyProfileRequest.DeleteMyProfileReason, rhs: Com_Octopuscommunity_DeleteMyProfileRequest.DeleteMyProfileReason) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteMyProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMyProfileResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteMyProfileResponse, rhs: Com_Octopuscommunity_DeleteMyProfileResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ReportUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "reasonCodes"),
    3: .same(proto: "customReason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reasonCodes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._customReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.reasonCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasonCodes, fieldNumber: 2)
    }
    try { if let v = self._customReason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ReportUserRequest, rhs: Com_Octopuscommunity_ReportUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.reasonCodes != rhs.reasonCodes {return false}
    if lhs._customReason != rhs._customReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ReportUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ReportUserResponse, rhs: Com_Octopuscommunity_ReportUserResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_BlockUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_BlockUserRequest, rhs: Com_Octopuscommunity_BlockUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_BlockUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_BlockUserResponse, rhs: Com_Octopuscommunity_BlockUserResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ByPassAbTestingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByPassAbTestingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "giveCommunityAccess"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.giveCommunityAccess) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.giveCommunityAccess != false {
      try visitor.visitSingularBoolField(value: self.giveCommunityAccess, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ByPassAbTestingRequest, rhs: Com_Octopuscommunity_ByPassAbTestingRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.giveCommunityAccess != rhs.giveCommunityAccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ByPassAbTestingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByPassAbTestingResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_ByPassAbTestingResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_ByPassAbTestingResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ByPassAbTestingResponse, rhs: Com_Octopuscommunity_ByPassAbTestingResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ByPassAbTestingResponse.ErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ERROR"),
  ]
}

extension Com_Octopuscommunity_ByPassAbTestingResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ByPassAbTestingResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jwt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jwt.isEmpty {
      try visitor.visitSingularStringField(value: self.jwt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ByPassAbTestingResponse.Success, rhs: Com_Octopuscommunity_ByPassAbTestingResponse.Success) -> Bool {
    if lhs.jwt != rhs.jwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ByPassAbTestingResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ByPassAbTestingResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ByPassAbTestingResponse.Fail, rhs: Com_Octopuscommunity_ByPassAbTestingResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ByPassAbTestingResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ByPassAbTestingResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errorCode"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .unknownError {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ByPassAbTestingResponse.Error, rhs: Com_Octopuscommunity_ByPassAbTestingResponse.Error) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_CanAccessCommunityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanAccessCommunityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_CanAccessCommunityRequest, rhs: Com_Octopuscommunity_CanAccessCommunityRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_CanAccessCommunityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanAccessCommunityResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "canAccessCommunity"),
    2: .same(proto: "communityDisabledMessage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canAccessCommunity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._communityDisabledMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.canAccessCommunity != false {
      try visitor.visitSingularBoolField(value: self.canAccessCommunity, fieldNumber: 1)
    }
    try { if let v = self._communityDisabledMessage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_CanAccessCommunityResponse, rhs: Com_Octopuscommunity_CanAccessCommunityResponse) -> Bool {
    if lhs.canAccessCommunity != rhs.canAccessCommunity {return false}
    if lhs._communityDisabledMessage != rhs._communityDisabledMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_SearchUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "clientUserId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "email"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.by != nil {try decoder.handleConflictingOneOf()}
          self.by = .userID(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.by != nil {try decoder.handleConflictingOneOf()}
          self.by = .clientUserID(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.by != nil {try decoder.handleConflictingOneOf()}
          self.by = .nickname(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.by != nil {try decoder.handleConflictingOneOf()}
          self.by = .email(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.by {
    case .userID?: try {
      guard case .userID(let v)? = self.by else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .clientUserID?: try {
      guard case .clientUserID(let v)? = self.by else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .nickname?: try {
      guard case .nickname(let v)? = self.by else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .email?: try {
      guard case .email(let v)? = self.by else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_SearchUserRequest, rhs: Com_Octopuscommunity_SearchUserRequest) -> Bool {
    if lhs.by != rhs.by {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_SearchUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_SearchUserResponse, rhs: Com_Octopuscommunity_SearchUserResponse) -> Bool {
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_SetProfileTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetProfileTagRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.tags.isEmpty {
      try visitor.visitPackedEnumField(value: self.tags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_SetProfileTagRequest, rhs: Com_Octopuscommunity_SetProfileTagRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_SetProfileTagResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetProfileTagResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_SetProfileTagResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_SetProfileTagResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_SetProfileTagResponse, rhs: Com_Octopuscommunity_SetProfileTagResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_SetProfileTagResponse.ErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ERROR"),
  ]
}

extension Com_Octopuscommunity_SetProfileTagResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_SetProfileTagResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_SetProfileTagResponse.Success, rhs: Com_Octopuscommunity_SetProfileTagResponse.Success) -> Bool {
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_SetProfileTagResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_SetProfileTagResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_SetProfileTagResponse.Fail, rhs: Com_Octopuscommunity_SetProfileTagResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_SetProfileTagResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_SetProfileTagResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errorCode"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .unknownError {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_SetProfileTagResponse.Error, rhs: Com_Octopuscommunity_SetProfileTagResponse.Error) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
