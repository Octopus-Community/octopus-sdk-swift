// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: com/octopuscommunity/OctoObjectServiceProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Com_Octopuscommunity_RwOctoObject: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parentID: String = String()

  public var content: Com_Octopuscommunity_Content {
    get {return _content ?? Com_Octopuscommunity_Content()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  ///  int64 createdAt;  server side determined by the put logged user
  ///  string createdBy;  server side determined by time of the put request
  /// string id; server side randomly generated
  public var pressedEnterAt: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _content: Com_Octopuscommunity_Content? = nil
}

public struct Com_Octopuscommunity_UpdatePostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var update: Com_Octopuscommunity_UpdatePostRequest.Update {
    get {return _update ?? Com_Octopuscommunity_UpdatePostRequest.Update()}
    set {_update = newValue}
  }
  /// Returns true if `update` has been explicitly set.
  public var hasUpdate: Bool {return self._update != nil}
  /// Clears the value of `update`. Subsequent reads from it will return its default value.
  public mutating func clearUpdate() {self._update = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Update: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var topicID: String {
      get {return _storage._topicID ?? String()}
      set {_uniqueStorage()._topicID = newValue}
    }
    /// Returns true if `topicID` has been explicitly set.
    public var hasTopicID: Bool {return _storage._topicID != nil}
    /// Clears the value of `topicID`. Subsequent reads from it will return its default value.
    public mutating func clearTopicID() {_uniqueStorage()._topicID = nil}

    public var postContent: Com_Octopuscommunity_Post {
      get {return _storage._postContent ?? Com_Octopuscommunity_Post()}
      set {_uniqueStorage()._postContent = newValue}
    }
    /// Returns true if `postContent` has been explicitly set.
    public var hasPostContent: Bool {return _storage._postContent != nil}
    /// Clears the value of `postContent`. Subsequent reads from it will return its default value.
    public mutating func clearPostContent() {_uniqueStorage()._postContent = nil}

    public var maxActivityScore: UInt64 {
      get {return _storage._maxActivityScore ?? 0}
      set {_uniqueStorage()._maxActivityScore = newValue}
    }
    /// Returns true if `maxActivityScore` has been explicitly set.
    public var hasMaxActivityScore: Bool {return _storage._maxActivityScore != nil}
    /// Clears the value of `maxActivityScore`. Subsequent reads from it will return its default value.
    public mutating func clearMaxActivityScore() {_uniqueStorage()._maxActivityScore = nil}

    public var deleteMaxActivityScore: Bool {
      get {return _storage._deleteMaxActivityScore ?? false}
      set {_uniqueStorage()._deleteMaxActivityScore = newValue}
    }
    /// Returns true if `deleteMaxActivityScore` has been explicitly set.
    public var hasDeleteMaxActivityScore: Bool {return _storage._deleteMaxActivityScore != nil}
    /// Clears the value of `deleteMaxActivityScore`. Subsequent reads from it will return its default value.
    public mutating func clearDeleteMaxActivityScore() {_uniqueStorage()._deleteMaxActivityScore = nil}

    public var minActivityScore: UInt64 {
      get {return _storage._minActivityScore ?? 0}
      set {_uniqueStorage()._minActivityScore = newValue}
    }
    /// Returns true if `minActivityScore` has been explicitly set.
    public var hasMinActivityScore: Bool {return _storage._minActivityScore != nil}
    /// Clears the value of `minActivityScore`. Subsequent reads from it will return its default value.
    public mutating func clearMinActivityScore() {_uniqueStorage()._minActivityScore = nil}

    public var deleteMinActivityScore: Bool {
      get {return _storage._deleteMinActivityScore ?? false}
      set {_uniqueStorage()._deleteMinActivityScore = newValue}
    }
    /// Returns true if `deleteMinActivityScore` has been explicitly set.
    public var hasDeleteMinActivityScore: Bool {return _storage._deleteMinActivityScore != nil}
    /// Clears the value of `deleteMinActivityScore`. Subsequent reads from it will return its default value.
    public mutating func clearDeleteMinActivityScore() {_uniqueStorage()._deleteMinActivityScore = nil}

    public var shadowBanned: Bool {
      get {return _storage._shadowBanned ?? false}
      set {_uniqueStorage()._shadowBanned = newValue}
    }
    /// Returns true if `shadowBanned` has been explicitly set.
    public var hasShadowBanned: Bool {return _storage._shadowBanned != nil}
    /// Clears the value of `shadowBanned`. Subsequent reads from it will return its default value.
    public mutating func clearShadowBanned() {_uniqueStorage()._shadowBanned = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _update: Com_Octopuscommunity_UpdatePostRequest.Update? = nil
}

public struct Com_Octopuscommunity_UpdatePostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_UpdatePostResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_UpdatePostResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_UpdatePostResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_UpdatePostResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_UpdatePostResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_UpdatePostResponse.Success)
    case fail(Com_Octopuscommunity_UpdatePostResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var post: Com_Octopuscommunity_OctoObject {
      get {return _post ?? Com_Octopuscommunity_OctoObject()}
      set {_post = newValue}
    }
    /// Returns true if `post` has been explicitly set.
    public var hasPost: Bool {return self._post != nil}
    /// Clears the value of `post`. Subsequent reads from it will return its default value.
    public mutating func clearPost() {self._post = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _post: Com_Octopuscommunity_OctoObject? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_UpdatePostResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var field: Com_Octopuscommunity_UpdatePostResponse.Error.Field {
      get {return _field ?? .unknown}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var details: Com_Octopuscommunity_UpdatePostResponse.Error.OneOf_Details? = nil

    public var missingText: Com_Octopuscommunity_ErrorDetails.MissingText {
      get {
        if case .missingText(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingText()
      }
      set {details = .missingText(newValue)}
    }

    public var bannedWordUsed: Com_Octopuscommunity_ErrorDetails.BannedWordUsed {
      get {
        if case .bannedWordUsed(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BannedWordUsed()
      }
      set {details = .bannedWordUsed(newValue)}
    }

    public var maxCharLimitReached: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached {
      get {
        if case .maxCharLimitReached(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached()
      }
      set {details = .maxCharLimitReached(newValue)}
    }

    public var emptyFile: Com_Octopuscommunity_ErrorDetails.EmptyFile {
      get {
        if case .emptyFile(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyFile()
      }
      set {details = .emptyFile(newValue)}
    }

    public var fileSizeTooBig: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig {
      get {
        if case .fileSizeTooBig(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.FileSizeTooBig()
      }
      set {details = .fileSizeTooBig(newValue)}
    }

    public var badFileFormat: Com_Octopuscommunity_ErrorDetails.BadFileFormat {
      get {
        if case .badFileFormat(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BadFileFormat()
      }
      set {details = .badFileFormat(newValue)}
    }

    public var uploadIssue: Com_Octopuscommunity_ErrorDetails.UploadIssue {
      get {
        if case .uploadIssue(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.UploadIssue()
      }
      set {details = .uploadIssue(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case missingText(Com_Octopuscommunity_ErrorDetails.MissingText)
      case bannedWordUsed(Com_Octopuscommunity_ErrorDetails.BannedWordUsed)
      case maxCharLimitReached(Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached)
      case emptyFile(Com_Octopuscommunity_ErrorDetails.EmptyFile)
      case fileSizeTooBig(Com_Octopuscommunity_ErrorDetails.FileSizeTooBig)
      case badFileFormat(Com_Octopuscommunity_ErrorDetails.BadFileFormat)
      case uploadIssue(Com_Octopuscommunity_ErrorDetails.UploadIssue)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0

      ///MissingText, BannedWordUsed, MaxCharLimitReached
      case contentText // = 2

      /// field 3 was "CONTENT_TEXT = 3;", now removed
      case contentFile // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 2: self = .contentText
        case 4: self = .contentFile
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contentText: return 2
        case .contentFile: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_UpdatePostResponse.Error.Field] = [
        .unknown,
        .contentText,
        .contentFile,
      ]

    }

    public init() {}

    fileprivate var _field: Com_Octopuscommunity_UpdatePostResponse.Error.Field? = nil
  }

  public init() {}
}

public struct Com_Octopuscommunity_GetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var fetchObject: Bool = false

  public var fetchRequesterCtx: Bool = false

  public var fetchAggregate: Bool = false

  public var registerView: Bool {
    get {return _registerView ?? false}
    set {_registerView = newValue}
  }
  /// Returns true if `registerView` has been explicitly set.
  public var hasRegisterView: Bool {return self._registerView != nil}
  /// Clears the value of `registerView`. Subsequent reads from it will return its default value.
  public mutating func clearRegisterView() {self._registerView = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _registerView: Bool? = nil
}

public struct Com_Octopuscommunity_GetResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String {
    get {return _storage._octoObjectID}
    set {_uniqueStorage()._octoObjectID = newValue}
  }

  public var octoObject: Com_Octopuscommunity_OctoObject {
    get {return _storage._octoObject ?? Com_Octopuscommunity_OctoObject()}
    set {_uniqueStorage()._octoObject = newValue}
  }
  /// Returns true if `octoObject` has been explicitly set.
  public var hasOctoObject: Bool {return _storage._octoObject != nil}
  /// Clears the value of `octoObject`. Subsequent reads from it will return its default value.
  public mutating func clearOctoObject() {_uniqueStorage()._octoObject = nil}

  public var aggregate: Com_Octopuscommunity_Aggregate {
    get {return _storage._aggregate ?? Com_Octopuscommunity_Aggregate()}
    set {_uniqueStorage()._aggregate = newValue}
  }
  /// Returns true if `aggregate` has been explicitly set.
  public var hasAggregate: Bool {return _storage._aggregate != nil}
  /// Clears the value of `aggregate`. Subsequent reads from it will return its default value.
  public mutating func clearAggregate() {_uniqueStorage()._aggregate = nil}

  public var requesterCtx: Com_Octopuscommunity_RequesterCtx {
    get {return _storage._requesterCtx ?? Com_Octopuscommunity_RequesterCtx()}
    set {_uniqueStorage()._requesterCtx = newValue}
  }
  /// Returns true if `requesterCtx` has been explicitly set.
  public var hasRequesterCtx: Bool {return _storage._requesterCtx != nil}
  /// Clears the value of `requesterCtx`. Subsequent reads from it will return its default value.
  public mutating func clearRequesterCtx() {_uniqueStorage()._requesterCtx = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Com_Octopuscommunity_GetBatchRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Com_Octopuscommunity_GetRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_GetBatchResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responses: [Com_Octopuscommunity_GetResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_PutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObject: Com_Octopuscommunity_RwOctoObject {
    get {return _octoObject ?? Com_Octopuscommunity_RwOctoObject()}
    set {_octoObject = newValue}
  }
  /// Returns true if `octoObject` has been explicitly set.
  public var hasOctoObject: Bool {return self._octoObject != nil}
  /// Clears the value of `octoObject`. Subsequent reads from it will return its default value.
  public mutating func clearOctoObject() {self._octoObject = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _octoObject: Com_Octopuscommunity_RwOctoObject? = nil
}

public struct Com_Octopuscommunity_PutCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_PutCommentResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_PutCommentResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_PutCommentResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_PutCommentResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_PutCommentResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_PutCommentResponse.Success)
    case fail(Com_Octopuscommunity_PutCommentResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var comment: Com_Octopuscommunity_OctoObject {
      get {return _comment ?? Com_Octopuscommunity_OctoObject()}
      set {_comment = newValue}
    }
    /// Returns true if `comment` has been explicitly set.
    public var hasComment: Bool {return self._comment != nil}
    /// Clears the value of `comment`. Subsequent reads from it will return its default value.
    public mutating func clearComment() {self._comment = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _comment: Com_Octopuscommunity_OctoObject? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_PutCommentResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var field: Com_Octopuscommunity_PutCommentResponse.Error.Field {
      get {return _field ?? .unknown}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var details: Com_Octopuscommunity_PutCommentResponse.Error.OneOf_Details? = nil

    public var missingParent: Com_Octopuscommunity_ErrorDetails.MissingParent {
      get {
        if case .missingParent(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingParent()
      }
      set {details = .missingParent(newValue)}
    }

    public var bannedWordUsed: Com_Octopuscommunity_ErrorDetails.BannedWordUsed {
      get {
        if case .bannedWordUsed(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BannedWordUsed()
      }
      set {details = .bannedWordUsed(newValue)}
    }

    public var maxCharLimitReached: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached {
      get {
        if case .maxCharLimitReached(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached()
      }
      set {details = .maxCharLimitReached(newValue)}
    }

    public var emptyFile: Com_Octopuscommunity_ErrorDetails.EmptyFile {
      get {
        if case .emptyFile(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyFile()
      }
      set {details = .emptyFile(newValue)}
    }

    public var fileSizeTooBig: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig {
      get {
        if case .fileSizeTooBig(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.FileSizeTooBig()
      }
      set {details = .fileSizeTooBig(newValue)}
    }

    public var badFileFormat: Com_Octopuscommunity_ErrorDetails.BadFileFormat {
      get {
        if case .badFileFormat(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BadFileFormat()
      }
      set {details = .badFileFormat(newValue)}
    }

    public var uploadIssue: Com_Octopuscommunity_ErrorDetails.UploadIssue {
      get {
        if case .uploadIssue(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.UploadIssue()
      }
      set {details = .uploadIssue(newValue)}
    }

    public var emptyPublication: Com_Octopuscommunity_ErrorDetails.EmptyPublication {
      get {
        if case .emptyPublication(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyPublication()
      }
      set {details = .emptyPublication(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case missingParent(Com_Octopuscommunity_ErrorDetails.MissingParent)
      case bannedWordUsed(Com_Octopuscommunity_ErrorDetails.BannedWordUsed)
      case maxCharLimitReached(Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached)
      case emptyFile(Com_Octopuscommunity_ErrorDetails.EmptyFile)
      case fileSizeTooBig(Com_Octopuscommunity_ErrorDetails.FileSizeTooBig)
      case badFileFormat(Com_Octopuscommunity_ErrorDetails.BadFileFormat)
      case uploadIssue(Com_Octopuscommunity_ErrorDetails.UploadIssue)
      case emptyPublication(Com_Octopuscommunity_ErrorDetails.EmptyPublication)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0

      ///MissingParent
      case contentParent // = 1

      ///BannedWordUsed, MaxCharLimitReached
      case contentText // = 2

      ///EmptyFile, FileSizeTooBig, BadFileFormat, UploadIssue
      case contentFile // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contentParent
        case 2: self = .contentText
        case 3: self = .contentFile
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contentParent: return 1
        case .contentText: return 2
        case .contentFile: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_PutCommentResponse.Error.Field] = [
        .unknown,
        .contentParent,
        .contentText,
        .contentFile,
      ]

    }

    public init() {}

    fileprivate var _field: Com_Octopuscommunity_PutCommentResponse.Error.Field? = nil
  }

  public init() {}
}

public struct Com_Octopuscommunity_PutReplyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_PutReplyResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_PutReplyResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_PutReplyResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_PutReplyResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_PutReplyResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_PutReplyResponse.Success)
    case fail(Com_Octopuscommunity_PutReplyResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var reply: Com_Octopuscommunity_OctoObject {
      get {return _reply ?? Com_Octopuscommunity_OctoObject()}
      set {_reply = newValue}
    }
    /// Returns true if `reply` has been explicitly set.
    public var hasReply: Bool {return self._reply != nil}
    /// Clears the value of `reply`. Subsequent reads from it will return its default value.
    public mutating func clearReply() {self._reply = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _reply: Com_Octopuscommunity_OctoObject? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_PutReplyResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var field: Com_Octopuscommunity_PutReplyResponse.Error.Field {
      get {return _field ?? .unknown}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var details: Com_Octopuscommunity_PutReplyResponse.Error.OneOf_Details? = nil

    public var missingParent: Com_Octopuscommunity_ErrorDetails.MissingParent {
      get {
        if case .missingParent(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingParent()
      }
      set {details = .missingParent(newValue)}
    }

    public var bannedWordUsed: Com_Octopuscommunity_ErrorDetails.BannedWordUsed {
      get {
        if case .bannedWordUsed(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BannedWordUsed()
      }
      set {details = .bannedWordUsed(newValue)}
    }

    public var maxCharLimitReached: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached {
      get {
        if case .maxCharLimitReached(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached()
      }
      set {details = .maxCharLimitReached(newValue)}
    }

    public var emptyFile: Com_Octopuscommunity_ErrorDetails.EmptyFile {
      get {
        if case .emptyFile(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyFile()
      }
      set {details = .emptyFile(newValue)}
    }

    public var fileSizeTooBig: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig {
      get {
        if case .fileSizeTooBig(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.FileSizeTooBig()
      }
      set {details = .fileSizeTooBig(newValue)}
    }

    public var badFileFormat: Com_Octopuscommunity_ErrorDetails.BadFileFormat {
      get {
        if case .badFileFormat(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BadFileFormat()
      }
      set {details = .badFileFormat(newValue)}
    }

    public var uploadIssue: Com_Octopuscommunity_ErrorDetails.UploadIssue {
      get {
        if case .uploadIssue(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.UploadIssue()
      }
      set {details = .uploadIssue(newValue)}
    }

    public var emptyPublication: Com_Octopuscommunity_ErrorDetails.EmptyPublication {
      get {
        if case .emptyPublication(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyPublication()
      }
      set {details = .emptyPublication(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case missingParent(Com_Octopuscommunity_ErrorDetails.MissingParent)
      case bannedWordUsed(Com_Octopuscommunity_ErrorDetails.BannedWordUsed)
      case maxCharLimitReached(Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached)
      case emptyFile(Com_Octopuscommunity_ErrorDetails.EmptyFile)
      case fileSizeTooBig(Com_Octopuscommunity_ErrorDetails.FileSizeTooBig)
      case badFileFormat(Com_Octopuscommunity_ErrorDetails.BadFileFormat)
      case uploadIssue(Com_Octopuscommunity_ErrorDetails.UploadIssue)
      case emptyPublication(Com_Octopuscommunity_ErrorDetails.EmptyPublication)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0

      ///MissingParent
      case contentParent // = 1

      ///BannedWordUsed, MaxCharLimitReached
      case contentText // = 2

      ///EmptyFile, FileSizeTooBig, BadFileFormat, UploadIssue
      case contentFile // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contentParent
        case 2: self = .contentText
        case 3: self = .contentFile
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contentParent: return 1
        case .contentText: return 2
        case .contentFile: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_PutReplyResponse.Error.Field] = [
        .unknown,
        .contentParent,
        .contentText,
        .contentFile,
      ]

    }

    public init() {}

    fileprivate var _field: Com_Octopuscommunity_PutReplyResponse.Error.Field? = nil
  }

  public init() {}
}

public struct Com_Octopuscommunity_PutPollVoteResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_PutPollVoteResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_PutPollVoteResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_PutPollVoteResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_PutPollVoteResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_PutPollVoteResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_PutPollVoteResponse.Success)
    case fail(Com_Octopuscommunity_PutPollVoteResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pollVote: Com_Octopuscommunity_OctoObject {
      get {return _pollVote ?? Com_Octopuscommunity_OctoObject()}
      set {_pollVote = newValue}
    }
    /// Returns true if `pollVote` has been explicitly set.
    public var hasPollVote: Bool {return self._pollVote != nil}
    /// Clears the value of `pollVote`. Subsequent reads from it will return its default value.
    public mutating func clearPollVote() {self._pollVote = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _pollVote: Com_Octopuscommunity_OctoObject? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_PutPollVoteResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var field: Com_Octopuscommunity_PutPollVoteResponse.Error.Field {
      get {return _field ?? .unknown}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var details: Com_Octopuscommunity_PutPollVoteResponse.Error.OneOf_Details? = nil

    public var missingParent: Com_Octopuscommunity_ErrorDetails.MissingParent {
      get {
        if case .missingParent(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingParent()
      }
      set {details = .missingParent(newValue)}
    }

    public var missingPollAnswer: Com_Octopuscommunity_ErrorDetails.MissingPollAnswer {
      get {
        if case .missingPollAnswer(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingPollAnswer()
      }
      set {details = .missingPollAnswer(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case missingParent(Com_Octopuscommunity_ErrorDetails.MissingParent)
      case missingPollAnswer(Com_Octopuscommunity_ErrorDetails.MissingPollAnswer)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0

      ///MissingParent
      case contentParent // = 1

      ///MissingPollAnswer
      case contentTarget // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contentParent
        case 2: self = .contentTarget
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contentParent: return 1
        case .contentTarget: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_PutPollVoteResponse.Error.Field] = [
        .unknown,
        .contentParent,
        .contentTarget,
      ]

    }

    public init() {}

    fileprivate var _field: Com_Octopuscommunity_PutPollVoteResponse.Error.Field? = nil
  }

  public init() {}
}

public struct Com_Octopuscommunity_PutPostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_PutPostResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_PutPostResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_PutPostResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_PutPostResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_PutPostResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_PutPostResponse.Success)
    case fail(Com_Octopuscommunity_PutPostResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var post: Com_Octopuscommunity_OctoObject {
      get {return _post ?? Com_Octopuscommunity_OctoObject()}
      set {_post = newValue}
    }
    /// Returns true if `post` has been explicitly set.
    public var hasPost: Bool {return self._post != nil}
    /// Clears the value of `post`. Subsequent reads from it will return its default value.
    public mutating func clearPost() {self._post = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _post: Com_Octopuscommunity_OctoObject? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_PutPostResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var field: Com_Octopuscommunity_PutPostResponse.Error.Field {
      get {return _field ?? .unknown}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var details: Com_Octopuscommunity_PutPostResponse.Error.OneOf_Details? = nil

    public var missingParent: Com_Octopuscommunity_ErrorDetails.MissingParent {
      get {
        if case .missingParent(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingParent()
      }
      set {details = .missingParent(newValue)}
    }

    public var missingText: Com_Octopuscommunity_ErrorDetails.MissingText {
      get {
        if case .missingText(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingText()
      }
      set {details = .missingText(newValue)}
    }

    public var bannedWordUsed: Com_Octopuscommunity_ErrorDetails.BannedWordUsed {
      get {
        if case .bannedWordUsed(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BannedWordUsed()
      }
      set {details = .bannedWordUsed(newValue)}
    }

    public var maxCharLimitReached: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached {
      get {
        if case .maxCharLimitReached(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached()
      }
      set {details = .maxCharLimitReached(newValue)}
    }

    public var emptyFile: Com_Octopuscommunity_ErrorDetails.EmptyFile {
      get {
        if case .emptyFile(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyFile()
      }
      set {details = .emptyFile(newValue)}
    }

    public var fileSizeTooBig: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig {
      get {
        if case .fileSizeTooBig(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.FileSizeTooBig()
      }
      set {details = .fileSizeTooBig(newValue)}
    }

    public var badFileFormat: Com_Octopuscommunity_ErrorDetails.BadFileFormat {
      get {
        if case .badFileFormat(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BadFileFormat()
      }
      set {details = .badFileFormat(newValue)}
    }

    public var uploadIssue: Com_Octopuscommunity_ErrorDetails.UploadIssue {
      get {
        if case .uploadIssue(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.UploadIssue()
      }
      set {details = .uploadIssue(newValue)}
    }

    public var badPollAnswerNumber: Com_Octopuscommunity_ErrorDetails.BadPollAnswerNumber {
      get {
        if case .badPollAnswerNumber(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BadPollAnswerNumber()
      }
      set {details = .badPollAnswerNumber(newValue)}
    }

    public var missingClientObjectID: Com_Octopuscommunity_ErrorDetails.MissingClientObjectId {
      get {
        if case .missingClientObjectID(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingClientObjectId()
      }
      set {details = .missingClientObjectID(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case missingParent(Com_Octopuscommunity_ErrorDetails.MissingParent)
      case missingText(Com_Octopuscommunity_ErrorDetails.MissingText)
      case bannedWordUsed(Com_Octopuscommunity_ErrorDetails.BannedWordUsed)
      case maxCharLimitReached(Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached)
      case emptyFile(Com_Octopuscommunity_ErrorDetails.EmptyFile)
      case fileSizeTooBig(Com_Octopuscommunity_ErrorDetails.FileSizeTooBig)
      case badFileFormat(Com_Octopuscommunity_ErrorDetails.BadFileFormat)
      case uploadIssue(Com_Octopuscommunity_ErrorDetails.UploadIssue)
      case badPollAnswerNumber(Com_Octopuscommunity_ErrorDetails.BadPollAnswerNumber)
      case missingClientObjectID(Com_Octopuscommunity_ErrorDetails.MissingClientObjectId)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0

      ///MissingParent
      case contentParent // = 1

      ///MissingText, BannedWordUsed, MaxCharLimitReached
      case contentText // = 2

      /// field 3 was "CONTENT_TEXT = 3;", now removed
      case contentFile // = 4

      ///MaxCharLimitReached, BadPollAnswerNumber
      case contentPoll // = 5

      ///MaxCharLimitReached
      case contentCatchphrase // = 6

      ///MaxCharLimitReached
      case contentCta // = 7

      ///MissingClientObjectId
      case contentClientObject // = 8
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contentParent
        case 2: self = .contentText
        case 4: self = .contentFile
        case 5: self = .contentPoll
        case 6: self = .contentCatchphrase
        case 7: self = .contentCta
        case 8: self = .contentClientObject
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contentParent: return 1
        case .contentText: return 2
        case .contentFile: return 4
        case .contentPoll: return 5
        case .contentCatchphrase: return 6
        case .contentCta: return 7
        case .contentClientObject: return 8
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_PutPostResponse.Error.Field] = [
        .unknown,
        .contentParent,
        .contentText,
        .contentFile,
        .contentPoll,
        .contentCatchphrase,
        .contentCta,
        .contentClientObject,
      ]

    }

    public init() {}

    fileprivate var _field: Com_Octopuscommunity_PutPostResponse.Error.Field? = nil
  }

  public init() {}
}

///Implicit community field determined from API_KEY or hard coded for V0.1
public struct Com_Octopuscommunity_GetTopicsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_GetTopicsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topics: [Com_Octopuscommunity_OctoObject] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeletePostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeletePostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeleteCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeleteCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeleteReplyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeleteReplyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ModeratePostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var reasonCodes: [Com_Octopuscommunity_StatusReasonCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ModeratePostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ModerateCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var reasonCodes: [Com_Octopuscommunity_StatusReasonCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ModerateCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ModerateReplyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var reasonCodes: [Com_Octopuscommunity_StatusReasonCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ModerateReplyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ShadowbanPostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ShadowbanPostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ShadowbanCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ShadowbanCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ShadowbanReplyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ShadowbanReplyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_UnshadowbanPostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_UnshadowbanPostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_UnshadowbanCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_UnshadowbanCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_UnshadowbanReplyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_UnshadowbanReplyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ReportContentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var reasonCodes: [Com_Octopuscommunity_ReportReasonCode] = []

  public var customReason: String {
    get {return _customReason ?? String()}
    set {_customReason = newValue}
  }
  /// Returns true if `customReason` has been explicitly set.
  public var hasCustomReason: Bool {return self._customReason != nil}
  /// Clears the value of `customReason`. Subsequent reads from it will return its default value.
  public mutating func clearCustomReason() {self._customReason = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _customReason: String? = nil
}

public struct Com_Octopuscommunity_ReportContentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_GetOrCreateBridgePostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Better to fill it for security reasons
  public var clientToken: String {
    get {return _clientToken ?? String()}
    set {_clientToken = newValue}
  }
  /// Returns true if `clientToken` has been explicitly set.
  public var hasClientToken: Bool {return self._clientToken != nil}
  /// Clears the value of `clientToken`. Subsequent reads from it will return its default value.
  public mutating func clearClientToken() {self._clientToken = nil}

  ///Default bridge topic if not filled
  public var topicID: String {
    get {return _topicID ?? String()}
    set {_topicID = newValue}
  }
  /// Returns true if `topicID` has been explicitly set.
  public var hasTopicID: Bool {return self._topicID != nil}
  /// Clears the value of `topicID`. Subsequent reads from it will return its default value.
  public mutating func clearTopicID() {self._topicID = nil}

  /// must contain bridgeToClientObject
  public var postBridge: Com_Octopuscommunity_Post {
    get {return _postBridge ?? Com_Octopuscommunity_Post()}
    set {_postBridge = newValue}
  }
  /// Returns true if `postBridge` has been explicitly set.
  public var hasPostBridge: Bool {return self._postBridge != nil}
  /// Clears the value of `postBridge`. Subsequent reads from it will return its default value.
  public mutating func clearPostBridge() {self._postBridge = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientToken: String? = nil
  fileprivate var _topicID: String? = nil
  fileprivate var _postBridge: Com_Octopuscommunity_Post? = nil
}

public struct Com_Octopuscommunity_GetOrCreateBridgePostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_GetOrCreateBridgePostResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_GetOrCreateBridgePostResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success)
    case fail(Com_Octopuscommunity_GetOrCreateBridgePostResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The created post
    public var postBridge: Com_Octopuscommunity_OctoObject {
      get {return _postBridge ?? Com_Octopuscommunity_OctoObject()}
      set {_postBridge = newValue}
    }
    /// Returns true if `postBridge` has been explicitly set.
    public var hasPostBridge: Bool {return self._postBridge != nil}
    /// Clears the value of `postBridge`. Subsequent reads from it will return its default value.
    public mutating func clearPostBridge() {self._postBridge = nil}

    /// Used for analytics only
    public var status: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success.ResponseStatus {
      get {return _status ?? .unknown}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    public var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    public mutating func clearStatus() {self._status = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ResponseStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0

      ///Post bridge created
      case created // = 1

      ///Existing post bridge retrieved
      case retrieved // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .created
        case 2: self = .retrieved
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .created: return 1
        case .retrieved: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success.ResponseStatus] = [
        .unknown,
        .created,
        .retrieved,
      ]

    }

    public init() {}

    fileprivate var _postBridge: Com_Octopuscommunity_OctoObject? = nil
    fileprivate var _status: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success.ResponseStatus? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_GetOrCreateBridgePostResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var field: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Error.Field {
      get {return _field ?? .unknown}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var details: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Error.OneOf_Details? = nil

    public var missingText: Com_Octopuscommunity_ErrorDetails.MissingText {
      get {
        if case .missingText(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingText()
      }
      set {details = .missingText(newValue)}
    }

    public var maxCharLimitReached: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached {
      get {
        if case .maxCharLimitReached(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached()
      }
      set {details = .maxCharLimitReached(newValue)}
    }

    public var emptyFile: Com_Octopuscommunity_ErrorDetails.EmptyFile {
      get {
        if case .emptyFile(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyFile()
      }
      set {details = .emptyFile(newValue)}
    }

    public var fileSizeTooBig: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig {
      get {
        if case .fileSizeTooBig(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.FileSizeTooBig()
      }
      set {details = .fileSizeTooBig(newValue)}
    }

    public var badFileFormat: Com_Octopuscommunity_ErrorDetails.BadFileFormat {
      get {
        if case .badFileFormat(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BadFileFormat()
      }
      set {details = .badFileFormat(newValue)}
    }

    public var uploadIssue: Com_Octopuscommunity_ErrorDetails.UploadIssue {
      get {
        if case .uploadIssue(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.UploadIssue()
      }
      set {details = .uploadIssue(newValue)}
    }

    public var downloadIssue: Com_Octopuscommunity_ErrorDetails.DownloadIssue {
      get {
        if case .downloadIssue(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.DownloadIssue()
      }
      set {details = .downloadIssue(newValue)}
    }

    public var missingCtaText: Com_Octopuscommunity_ErrorDetails.MissingCtaText {
      get {
        if case .missingCtaText(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingCtaText()
      }
      set {details = .missingCtaText(newValue)}
    }

    public var missingClientObjectID: Com_Octopuscommunity_ErrorDetails.MissingClientObjectId {
      get {
        if case .missingClientObjectID(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingClientObjectId()
      }
      set {details = .missingClientObjectID(newValue)}
    }

    public var invalidClientToken: Com_Octopuscommunity_ErrorDetails.InvalidClientToken {
      get {
        if case .invalidClientToken(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.InvalidClientToken()
      }
      set {details = .invalidClientToken(newValue)}
    }

    public var bridgePostUnavailable: Com_Octopuscommunity_ErrorDetails.BridgePostUnavailable {
      get {
        if case .bridgePostUnavailable(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BridgePostUnavailable()
      }
      set {details = .bridgePostUnavailable(newValue)}
    }

    public var expiredClientToken: Com_Octopuscommunity_ErrorDetails.ExpiredClientToken {
      get {
        if case .expiredClientToken(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.ExpiredClientToken()
      }
      set {details = .expiredClientToken(newValue)}
    }

    public var invalidTopicID: Com_Octopuscommunity_ErrorDetails.InvalidTopicId {
      get {
        if case .invalidTopicID(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.InvalidTopicId()
      }
      set {details = .invalidTopicID(newValue)}
    }

    public var invalidAuthor: Com_Octopuscommunity_ErrorDetails.InvalidAuthor {
      get {
        if case .invalidAuthor(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.InvalidAuthor()
      }
      set {details = .invalidAuthor(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case missingText(Com_Octopuscommunity_ErrorDetails.MissingText)
      case maxCharLimitReached(Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached)
      case emptyFile(Com_Octopuscommunity_ErrorDetails.EmptyFile)
      case fileSizeTooBig(Com_Octopuscommunity_ErrorDetails.FileSizeTooBig)
      case badFileFormat(Com_Octopuscommunity_ErrorDetails.BadFileFormat)
      case uploadIssue(Com_Octopuscommunity_ErrorDetails.UploadIssue)
      case downloadIssue(Com_Octopuscommunity_ErrorDetails.DownloadIssue)
      case missingCtaText(Com_Octopuscommunity_ErrorDetails.MissingCtaText)
      case missingClientObjectID(Com_Octopuscommunity_ErrorDetails.MissingClientObjectId)
      case invalidClientToken(Com_Octopuscommunity_ErrorDetails.InvalidClientToken)
      case bridgePostUnavailable(Com_Octopuscommunity_ErrorDetails.BridgePostUnavailable)
      case expiredClientToken(Com_Octopuscommunity_ErrorDetails.ExpiredClientToken)
      case invalidTopicID(Com_Octopuscommunity_ErrorDetails.InvalidTopicId)
      case invalidAuthor(Com_Octopuscommunity_ErrorDetails.InvalidAuthor)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// InvalidClientToken, ExpiredClientToken
      case unknown // = 0

      ///MissingText, MaxCharLimitReached
      case contentText // = 1

      ///EmptyFile, FileSizeTooBig, BadFileFormat, UploadIssue, DownloadIssue
      case contentFile // = 2

      ///MissingCtaText, MissingClientObjectId, BridgePostUnavailable, InvalidTopicIc, InvalidAuthor
      case contentClientObject // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contentText
        case 2: self = .contentFile
        case 3: self = .contentClientObject
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contentText: return 1
        case .contentFile: return 2
        case .contentClientObject: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_GetOrCreateBridgePostResponse.Error.Field] = [
        .unknown,
        .contentText,
        .contentFile,
        .contentClientObject,
      ]

    }

    public init() {}

    fileprivate var _field: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Error.Field? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.octopuscommunity"

extension Com_Octopuscommunity_RwOctoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RwOctoObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parentId"),
    2: .same(proto: "content"),
    3: .same(proto: "pressedEnterAt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.pressedEnterAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parentID.isEmpty {
      try visitor.visitSingularStringField(value: self.parentID, fieldNumber: 1)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pressedEnterAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.pressedEnterAt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_RwOctoObject, rhs: Com_Octopuscommunity_RwOctoObject) -> Bool {
    if lhs.parentID != rhs.parentID {return false}
    if lhs._content != rhs._content {return false}
    if lhs.pressedEnterAt != rhs.pressedEnterAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._update) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try { if let v = self._update {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostRequest, rhs: Com_Octopuscommunity_UpdatePostRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs._update != rhs._update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostRequest.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdatePostRequest.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicId"),
    2: .same(proto: "postContent"),
    3: .same(proto: "maxActivityScore"),
    31: .same(proto: "deleteMaxActivityScore"),
    4: .same(proto: "minActivityScore"),
    41: .same(proto: "deleteMinActivityScore"),
    5: .same(proto: "shadowBanned"),
  ]

  fileprivate class _StorageClass {
    var _topicID: String? = nil
    var _postContent: Com_Octopuscommunity_Post? = nil
    var _maxActivityScore: UInt64? = nil
    var _deleteMaxActivityScore: Bool? = nil
    var _minActivityScore: UInt64? = nil
    var _deleteMinActivityScore: Bool? = nil
    var _shadowBanned: Bool? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _topicID = source._topicID
      _postContent = source._postContent
      _maxActivityScore = source._maxActivityScore
      _deleteMaxActivityScore = source._deleteMaxActivityScore
      _minActivityScore = source._minActivityScore
      _deleteMinActivityScore = source._deleteMinActivityScore
      _shadowBanned = source._shadowBanned
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._topicID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._postContent) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxActivityScore) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._minActivityScore) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._shadowBanned) }()
        case 31: try { try decoder.decodeSingularBoolField(value: &_storage._deleteMaxActivityScore) }()
        case 41: try { try decoder.decodeSingularBoolField(value: &_storage._deleteMinActivityScore) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._topicID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._postContent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._maxActivityScore {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._minActivityScore {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._shadowBanned {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._deleteMaxActivityScore {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._deleteMinActivityScore {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 41)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostRequest.Update, rhs: Com_Octopuscommunity_UpdatePostRequest.Update) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._topicID != rhs_storage._topicID {return false}
        if _storage._postContent != rhs_storage._postContent {return false}
        if _storage._maxActivityScore != rhs_storage._maxActivityScore {return false}
        if _storage._deleteMaxActivityScore != rhs_storage._deleteMaxActivityScore {return false}
        if _storage._minActivityScore != rhs_storage._minActivityScore {return false}
        if _storage._deleteMinActivityScore != rhs_storage._deleteMinActivityScore {return false}
        if _storage._shadowBanned != rhs_storage._shadowBanned {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePostResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_UpdatePostResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_UpdatePostResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostResponse, rhs: Com_Octopuscommunity_UpdatePostResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdatePostResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "post"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._post) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._post {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostResponse.Success, rhs: Com_Octopuscommunity_UpdatePostResponse.Success) -> Bool {
    if lhs._post != rhs._post {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdatePostResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostResponse.Fail, rhs: Com_Octopuscommunity_UpdatePostResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdatePostResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    102: .same(proto: "missingText"),
    103: .same(proto: "bannedWordUsed"),
    104: .same(proto: "maxCharLimitReached"),
    105: .same(proto: "emptyFile"),
    106: .same(proto: "fileSizeTooBig"),
    107: .same(proto: "badFileFormat"),
    108: .same(proto: "uploadIssue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._field) }()
      case 102: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingText?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingText(v)
        }
      }()
      case 103: try {
        var v: Com_Octopuscommunity_ErrorDetails.BannedWordUsed?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .bannedWordUsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .bannedWordUsed(v)
        }
      }()
      case 104: try {
        var v: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .maxCharLimitReached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .maxCharLimitReached(v)
        }
      }()
      case 105: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyFile?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyFile(v)
        }
      }()
      case 106: try {
        var v: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .fileSizeTooBig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .fileSizeTooBig(v)
        }
      }()
      case 107: try {
        var v: Com_Octopuscommunity_ErrorDetails.BadFileFormat?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badFileFormat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badFileFormat(v)
        }
      }()
      case 108: try {
        var v: Com_Octopuscommunity_ErrorDetails.UploadIssue?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .uploadIssue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .uploadIssue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._field {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    switch self.details {
    case .missingText?: try {
      guard case .missingText(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .bannedWordUsed?: try {
      guard case .bannedWordUsed(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .maxCharLimitReached?: try {
      guard case .maxCharLimitReached(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .emptyFile?: try {
      guard case .emptyFile(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .fileSizeTooBig?: try {
      guard case .fileSizeTooBig(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .badFileFormat?: try {
      guard case .badFileFormat(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .uploadIssue?: try {
      guard case .uploadIssue(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostResponse.Error, rhs: Com_Octopuscommunity_UpdatePostResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    2: .same(proto: "CONTENT_TEXT"),
    4: .same(proto: "CONTENT_FILE"),
  ]
}

extension Com_Octopuscommunity_GetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "fetchObject"),
    3: .same(proto: "fetchRequesterCtx"),
    4: .same(proto: "fetchAggregate"),
    6: .same(proto: "registerView"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.fetchObject) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.fetchRequesterCtx) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.fetchAggregate) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._registerView) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    if self.fetchObject != false {
      try visitor.visitSingularBoolField(value: self.fetchObject, fieldNumber: 2)
    }
    if self.fetchRequesterCtx != false {
      try visitor.visitSingularBoolField(value: self.fetchRequesterCtx, fieldNumber: 3)
    }
    if self.fetchAggregate != false {
      try visitor.visitSingularBoolField(value: self.fetchAggregate, fieldNumber: 4)
    }
    try { if let v = self._registerView {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetRequest, rhs: Com_Octopuscommunity_GetRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.fetchObject != rhs.fetchObject {return false}
    if lhs.fetchRequesterCtx != rhs.fetchRequesterCtx {return false}
    if lhs.fetchAggregate != rhs.fetchAggregate {return false}
    if lhs._registerView != rhs._registerView {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "octoObject"),
    3: .same(proto: "aggregate"),
    4: .same(proto: "requesterCtx"),
  ]

  fileprivate class _StorageClass {
    var _octoObjectID: String = String()
    var _octoObject: Com_Octopuscommunity_OctoObject? = nil
    var _aggregate: Com_Octopuscommunity_Aggregate? = nil
    var _requesterCtx: Com_Octopuscommunity_RequesterCtx? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _octoObjectID = source._octoObjectID
      _octoObject = source._octoObject
      _aggregate = source._aggregate
      _requesterCtx = source._requesterCtx
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._octoObjectID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._octoObject) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._aggregate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._requesterCtx) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._octoObjectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._octoObjectID, fieldNumber: 1)
      }
      try { if let v = _storage._octoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._aggregate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._requesterCtx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetResponse, rhs: Com_Octopuscommunity_GetResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._octoObjectID != rhs_storage._octoObjectID {return false}
        if _storage._octoObject != rhs_storage._octoObject {return false}
        if _storage._aggregate != rhs_storage._aggregate {return false}
        if _storage._requesterCtx != rhs_storage._requesterCtx {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetBatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBatchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetBatchRequest, rhs: Com_Octopuscommunity_GetBatchRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBatchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "responses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetBatchResponse, rhs: Com_Octopuscommunity_GetBatchResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObject"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._octoObject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._octoObject {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutRequest, rhs: Com_Octopuscommunity_PutRequest) -> Bool {
    if lhs._octoObject != rhs._octoObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutCommentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_PutCommentResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_PutCommentResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutCommentResponse, rhs: Com_Octopuscommunity_PutCommentResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutCommentResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutCommentResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "comment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._comment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._comment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutCommentResponse.Success, rhs: Com_Octopuscommunity_PutCommentResponse.Success) -> Bool {
    if lhs._comment != rhs._comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutCommentResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutCommentResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutCommentResponse.Fail, rhs: Com_Octopuscommunity_PutCommentResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutCommentResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutCommentResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    101: .same(proto: "missingParent"),
    102: .same(proto: "bannedWordUsed"),
    103: .same(proto: "maxCharLimitReached"),
    104: .same(proto: "emptyFile"),
    105: .same(proto: "fileSizeTooBig"),
    106: .same(proto: "badFileFormat"),
    107: .same(proto: "uploadIssue"),
    108: .same(proto: "emptyPublication"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._field) }()
      case 101: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingParent?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingParent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingParent(v)
        }
      }()
      case 102: try {
        var v: Com_Octopuscommunity_ErrorDetails.BannedWordUsed?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .bannedWordUsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .bannedWordUsed(v)
        }
      }()
      case 103: try {
        var v: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .maxCharLimitReached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .maxCharLimitReached(v)
        }
      }()
      case 104: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyFile?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyFile(v)
        }
      }()
      case 105: try {
        var v: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .fileSizeTooBig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .fileSizeTooBig(v)
        }
      }()
      case 106: try {
        var v: Com_Octopuscommunity_ErrorDetails.BadFileFormat?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badFileFormat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badFileFormat(v)
        }
      }()
      case 107: try {
        var v: Com_Octopuscommunity_ErrorDetails.UploadIssue?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .uploadIssue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .uploadIssue(v)
        }
      }()
      case 108: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyPublication?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyPublication(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyPublication(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._field {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    switch self.details {
    case .missingParent?: try {
      guard case .missingParent(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .bannedWordUsed?: try {
      guard case .bannedWordUsed(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .maxCharLimitReached?: try {
      guard case .maxCharLimitReached(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .emptyFile?: try {
      guard case .emptyFile(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .fileSizeTooBig?: try {
      guard case .fileSizeTooBig(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .badFileFormat?: try {
      guard case .badFileFormat(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .uploadIssue?: try {
      guard case .uploadIssue(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .emptyPublication?: try {
      guard case .emptyPublication(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutCommentResponse.Error, rhs: Com_Octopuscommunity_PutCommentResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutCommentResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTENT_PARENT"),
    2: .same(proto: "CONTENT_TEXT"),
    3: .same(proto: "CONTENT_FILE"),
  ]
}

extension Com_Octopuscommunity_PutReplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutReplyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_PutReplyResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_PutReplyResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutReplyResponse, rhs: Com_Octopuscommunity_PutReplyResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutReplyResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutReplyResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reply"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._reply) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._reply {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutReplyResponse.Success, rhs: Com_Octopuscommunity_PutReplyResponse.Success) -> Bool {
    if lhs._reply != rhs._reply {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutReplyResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutReplyResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutReplyResponse.Fail, rhs: Com_Octopuscommunity_PutReplyResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutReplyResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutReplyResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    101: .same(proto: "missingParent"),
    102: .same(proto: "bannedWordUsed"),
    103: .same(proto: "maxCharLimitReached"),
    104: .same(proto: "emptyFile"),
    105: .same(proto: "fileSizeTooBig"),
    106: .same(proto: "badFileFormat"),
    107: .same(proto: "uploadIssue"),
    108: .same(proto: "emptyPublication"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._field) }()
      case 101: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingParent?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingParent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingParent(v)
        }
      }()
      case 102: try {
        var v: Com_Octopuscommunity_ErrorDetails.BannedWordUsed?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .bannedWordUsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .bannedWordUsed(v)
        }
      }()
      case 103: try {
        var v: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .maxCharLimitReached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .maxCharLimitReached(v)
        }
      }()
      case 104: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyFile?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyFile(v)
        }
      }()
      case 105: try {
        var v: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .fileSizeTooBig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .fileSizeTooBig(v)
        }
      }()
      case 106: try {
        var v: Com_Octopuscommunity_ErrorDetails.BadFileFormat?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badFileFormat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badFileFormat(v)
        }
      }()
      case 107: try {
        var v: Com_Octopuscommunity_ErrorDetails.UploadIssue?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .uploadIssue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .uploadIssue(v)
        }
      }()
      case 108: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyPublication?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyPublication(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyPublication(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._field {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    switch self.details {
    case .missingParent?: try {
      guard case .missingParent(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .bannedWordUsed?: try {
      guard case .bannedWordUsed(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .maxCharLimitReached?: try {
      guard case .maxCharLimitReached(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .emptyFile?: try {
      guard case .emptyFile(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .fileSizeTooBig?: try {
      guard case .fileSizeTooBig(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .badFileFormat?: try {
      guard case .badFileFormat(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .uploadIssue?: try {
      guard case .uploadIssue(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .emptyPublication?: try {
      guard case .emptyPublication(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutReplyResponse.Error, rhs: Com_Octopuscommunity_PutReplyResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutReplyResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTENT_PARENT"),
    2: .same(proto: "CONTENT_TEXT"),
    3: .same(proto: "CONTENT_FILE"),
  ]
}

extension Com_Octopuscommunity_PutPollVoteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutPollVoteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_PutPollVoteResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_PutPollVoteResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPollVoteResponse, rhs: Com_Octopuscommunity_PutPollVoteResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPollVoteResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutPollVoteResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pollVote"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pollVote) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pollVote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPollVoteResponse.Success, rhs: Com_Octopuscommunity_PutPollVoteResponse.Success) -> Bool {
    if lhs._pollVote != rhs._pollVote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPollVoteResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutPollVoteResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPollVoteResponse.Fail, rhs: Com_Octopuscommunity_PutPollVoteResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPollVoteResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutPollVoteResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    101: .same(proto: "missingParent"),
    102: .same(proto: "missingPollAnswer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._field) }()
      case 101: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingParent?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingParent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingParent(v)
        }
      }()
      case 102: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingPollAnswer?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingPollAnswer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingPollAnswer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._field {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    switch self.details {
    case .missingParent?: try {
      guard case .missingParent(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .missingPollAnswer?: try {
      guard case .missingPollAnswer(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPollVoteResponse.Error, rhs: Com_Octopuscommunity_PutPollVoteResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPollVoteResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTENT_PARENT"),
    2: .same(proto: "CONTENT_TARGET"),
  ]
}

extension Com_Octopuscommunity_PutPostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutPostResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_PutPostResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_PutPostResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPostResponse, rhs: Com_Octopuscommunity_PutPostResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPostResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutPostResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "post"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._post) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._post {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPostResponse.Success, rhs: Com_Octopuscommunity_PutPostResponse.Success) -> Bool {
    if lhs._post != rhs._post {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPostResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutPostResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPostResponse.Fail, rhs: Com_Octopuscommunity_PutPostResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPostResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutPostResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    101: .same(proto: "missingParent"),
    102: .same(proto: "missingText"),
    103: .same(proto: "bannedWordUsed"),
    104: .same(proto: "maxCharLimitReached"),
    105: .same(proto: "emptyFile"),
    106: .same(proto: "fileSizeTooBig"),
    107: .same(proto: "badFileFormat"),
    108: .same(proto: "uploadIssue"),
    109: .same(proto: "badPollAnswerNumber"),
    110: .same(proto: "missingClientObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._field) }()
      case 101: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingParent?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingParent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingParent(v)
        }
      }()
      case 102: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingText?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingText(v)
        }
      }()
      case 103: try {
        var v: Com_Octopuscommunity_ErrorDetails.BannedWordUsed?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .bannedWordUsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .bannedWordUsed(v)
        }
      }()
      case 104: try {
        var v: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .maxCharLimitReached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .maxCharLimitReached(v)
        }
      }()
      case 105: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyFile?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyFile(v)
        }
      }()
      case 106: try {
        var v: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .fileSizeTooBig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .fileSizeTooBig(v)
        }
      }()
      case 107: try {
        var v: Com_Octopuscommunity_ErrorDetails.BadFileFormat?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badFileFormat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badFileFormat(v)
        }
      }()
      case 108: try {
        var v: Com_Octopuscommunity_ErrorDetails.UploadIssue?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .uploadIssue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .uploadIssue(v)
        }
      }()
      case 109: try {
        var v: Com_Octopuscommunity_ErrorDetails.BadPollAnswerNumber?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badPollAnswerNumber(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badPollAnswerNumber(v)
        }
      }()
      case 110: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingClientObjectId?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingClientObjectID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingClientObjectID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._field {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    switch self.details {
    case .missingParent?: try {
      guard case .missingParent(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .missingText?: try {
      guard case .missingText(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .bannedWordUsed?: try {
      guard case .bannedWordUsed(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .maxCharLimitReached?: try {
      guard case .maxCharLimitReached(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .emptyFile?: try {
      guard case .emptyFile(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .fileSizeTooBig?: try {
      guard case .fileSizeTooBig(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .badFileFormat?: try {
      guard case .badFileFormat(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .uploadIssue?: try {
      guard case .uploadIssue(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .badPollAnswerNumber?: try {
      guard case .badPollAnswerNumber(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .missingClientObjectID?: try {
      guard case .missingClientObjectID(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPostResponse.Error, rhs: Com_Octopuscommunity_PutPostResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPostResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTENT_PARENT"),
    2: .same(proto: "CONTENT_TEXT"),
    4: .same(proto: "CONTENT_FILE"),
    5: .same(proto: "CONTENT_POLL"),
    6: .same(proto: "CONTENT_CATCHPHRASE"),
    7: .same(proto: "CONTENT_CTA"),
    8: .same(proto: "CONTENT_CLIENT_OBJECT"),
  ]
}

extension Com_Octopuscommunity_GetTopicsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTopicsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetTopicsRequest, rhs: Com_Octopuscommunity_GetTopicsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetTopicsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTopicsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetTopicsResponse, rhs: Com_Octopuscommunity_GetTopicsResponse) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeletePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeletePostRequest, rhs: Com_Octopuscommunity_DeletePostRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeletePostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePostResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeletePostResponse, rhs: Com_Octopuscommunity_DeletePostResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCommentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteCommentRequest, rhs: Com_Octopuscommunity_DeleteCommentRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteCommentResponse, rhs: Com_Octopuscommunity_DeleteCommentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteReplyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteReplyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteReplyRequest, rhs: Com_Octopuscommunity_DeleteReplyRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteReplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteReplyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteReplyResponse, rhs: Com_Octopuscommunity_DeleteReplyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ModeratePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModeratePostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "reasonCodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reasonCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    if !self.reasonCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasonCodes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ModeratePostRequest, rhs: Com_Octopuscommunity_ModeratePostRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.reasonCodes != rhs.reasonCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ModeratePostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModeratePostResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ModeratePostResponse, rhs: Com_Octopuscommunity_ModeratePostResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ModerateCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModerateCommentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "reasonCodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reasonCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    if !self.reasonCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasonCodes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ModerateCommentRequest, rhs: Com_Octopuscommunity_ModerateCommentRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.reasonCodes != rhs.reasonCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ModerateCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModerateCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ModerateCommentResponse, rhs: Com_Octopuscommunity_ModerateCommentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ModerateReplyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModerateReplyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "reasonCodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reasonCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    if !self.reasonCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasonCodes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ModerateReplyRequest, rhs: Com_Octopuscommunity_ModerateReplyRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.reasonCodes != rhs.reasonCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ModerateReplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModerateReplyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ModerateReplyResponse, rhs: Com_Octopuscommunity_ModerateReplyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ShadowbanPostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShadowbanPostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ShadowbanPostRequest, rhs: Com_Octopuscommunity_ShadowbanPostRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ShadowbanPostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShadowbanPostResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ShadowbanPostResponse, rhs: Com_Octopuscommunity_ShadowbanPostResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ShadowbanCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShadowbanCommentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ShadowbanCommentRequest, rhs: Com_Octopuscommunity_ShadowbanCommentRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ShadowbanCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShadowbanCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ShadowbanCommentResponse, rhs: Com_Octopuscommunity_ShadowbanCommentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ShadowbanReplyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShadowbanReplyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ShadowbanReplyRequest, rhs: Com_Octopuscommunity_ShadowbanReplyRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ShadowbanReplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShadowbanReplyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ShadowbanReplyResponse, rhs: Com_Octopuscommunity_ShadowbanReplyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UnshadowbanPostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnshadowbanPostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UnshadowbanPostRequest, rhs: Com_Octopuscommunity_UnshadowbanPostRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UnshadowbanPostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnshadowbanPostResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UnshadowbanPostResponse, rhs: Com_Octopuscommunity_UnshadowbanPostResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UnshadowbanCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnshadowbanCommentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UnshadowbanCommentRequest, rhs: Com_Octopuscommunity_UnshadowbanCommentRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UnshadowbanCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnshadowbanCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UnshadowbanCommentResponse, rhs: Com_Octopuscommunity_UnshadowbanCommentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UnshadowbanReplyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnshadowbanReplyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UnshadowbanReplyRequest, rhs: Com_Octopuscommunity_UnshadowbanReplyRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UnshadowbanReplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnshadowbanReplyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UnshadowbanReplyResponse, rhs: Com_Octopuscommunity_UnshadowbanReplyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ReportContentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportContentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "reasonCodes"),
    3: .same(proto: "customReason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reasonCodes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._customReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    if !self.reasonCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasonCodes, fieldNumber: 2)
    }
    try { if let v = self._customReason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ReportContentRequest, rhs: Com_Octopuscommunity_ReportContentRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.reasonCodes != rhs.reasonCodes {return false}
    if lhs._customReason != rhs._customReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ReportContentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportContentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ReportContentResponse, rhs: Com_Octopuscommunity_ReportContentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetOrCreateBridgePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrCreateBridgePostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientToken"),
    2: .same(proto: "topicId"),
    3: .same(proto: "postBridge"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._clientToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._topicID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._postBridge) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clientToken {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topicID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._postBridge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetOrCreateBridgePostRequest, rhs: Com_Octopuscommunity_GetOrCreateBridgePostRequest) -> Bool {
    if lhs._clientToken != rhs._clientToken {return false}
    if lhs._topicID != rhs._topicID {return false}
    if lhs._postBridge != rhs._postBridge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetOrCreateBridgePostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrCreateBridgePostResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetOrCreateBridgePostResponse, rhs: Com_Octopuscommunity_GetOrCreateBridgePostResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_GetOrCreateBridgePostResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "postBridge"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._postBridge) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._postBridge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success, rhs: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success) -> Bool {
    if lhs._postBridge != rhs._postBridge {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetOrCreateBridgePostResponse.Success.ResponseStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CREATED"),
    2: .same(proto: "RETRIEVED"),
  ]
}

extension Com_Octopuscommunity_GetOrCreateBridgePostResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_GetOrCreateBridgePostResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Fail, rhs: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetOrCreateBridgePostResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_GetOrCreateBridgePostResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    101: .same(proto: "missingText"),
    102: .same(proto: "maxCharLimitReached"),
    103: .same(proto: "emptyFile"),
    104: .same(proto: "fileSizeTooBig"),
    105: .same(proto: "badFileFormat"),
    106: .same(proto: "uploadIssue"),
    107: .same(proto: "downloadIssue"),
    108: .same(proto: "missingCtaText"),
    109: .same(proto: "missingClientObjectId"),
    110: .same(proto: "invalidClientToken"),
    111: .same(proto: "bridgePostUnavailable"),
    112: .same(proto: "expiredClientToken"),
    113: .same(proto: "invalidTopicId"),
    114: .same(proto: "invalidAuthor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._field) }()
      case 101: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingText?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingText(v)
        }
      }()
      case 102: try {
        var v: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .maxCharLimitReached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .maxCharLimitReached(v)
        }
      }()
      case 103: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyFile?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyFile(v)
        }
      }()
      case 104: try {
        var v: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .fileSizeTooBig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .fileSizeTooBig(v)
        }
      }()
      case 105: try {
        var v: Com_Octopuscommunity_ErrorDetails.BadFileFormat?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badFileFormat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badFileFormat(v)
        }
      }()
      case 106: try {
        var v: Com_Octopuscommunity_ErrorDetails.UploadIssue?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .uploadIssue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .uploadIssue(v)
        }
      }()
      case 107: try {
        var v: Com_Octopuscommunity_ErrorDetails.DownloadIssue?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .downloadIssue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .downloadIssue(v)
        }
      }()
      case 108: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingCtaText?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingCtaText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingCtaText(v)
        }
      }()
      case 109: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingClientObjectId?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingClientObjectID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingClientObjectID(v)
        }
      }()
      case 110: try {
        var v: Com_Octopuscommunity_ErrorDetails.InvalidClientToken?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .invalidClientToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .invalidClientToken(v)
        }
      }()
      case 111: try {
        var v: Com_Octopuscommunity_ErrorDetails.BridgePostUnavailable?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .bridgePostUnavailable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .bridgePostUnavailable(v)
        }
      }()
      case 112: try {
        var v: Com_Octopuscommunity_ErrorDetails.ExpiredClientToken?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .expiredClientToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .expiredClientToken(v)
        }
      }()
      case 113: try {
        var v: Com_Octopuscommunity_ErrorDetails.InvalidTopicId?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .invalidTopicID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .invalidTopicID(v)
        }
      }()
      case 114: try {
        var v: Com_Octopuscommunity_ErrorDetails.InvalidAuthor?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .invalidAuthor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .invalidAuthor(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._field {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    switch self.details {
    case .missingText?: try {
      guard case .missingText(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .maxCharLimitReached?: try {
      guard case .maxCharLimitReached(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .emptyFile?: try {
      guard case .emptyFile(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .fileSizeTooBig?: try {
      guard case .fileSizeTooBig(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .badFileFormat?: try {
      guard case .badFileFormat(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .uploadIssue?: try {
      guard case .uploadIssue(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .downloadIssue?: try {
      guard case .downloadIssue(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .missingCtaText?: try {
      guard case .missingCtaText(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .missingClientObjectID?: try {
      guard case .missingClientObjectID(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .invalidClientToken?: try {
      guard case .invalidClientToken(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .bridgePostUnavailable?: try {
      guard case .bridgePostUnavailable(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
    }()
    case .expiredClientToken?: try {
      guard case .expiredClientToken(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
    }()
    case .invalidTopicID?: try {
      guard case .invalidTopicID(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
    }()
    case .invalidAuthor?: try {
      guard case .invalidAuthor(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Error, rhs: Com_Octopuscommunity_GetOrCreateBridgePostResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetOrCreateBridgePostResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTENT_TEXT"),
    2: .same(proto: "CONTENT_FILE"),
    3: .same(proto: "CONTENT_CLIENT_OBJECT"),
  ]
}
