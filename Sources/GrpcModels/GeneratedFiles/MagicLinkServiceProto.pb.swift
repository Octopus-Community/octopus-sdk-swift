// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: com/octopuscommunity/MagicLinkServiceProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Possible statuses when confirming a magic link.
public enum Com_Octopuscommunity_ConfirmLinkStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecifiedLinkStatus // = 0

  /// The link has strongly expired (cannot be used).
  case expiredStrong // = 1

  /// The link has weakly expired (can be refreshed).
  case expiredWeak // = 2

  /// The link has already been used.
  case alreadyUsed // = 3

  /// The link is valid and the user is authenticated.
  case authenticated // = 4

  /// The user related to the magic link is banned
  case unauthorized // = 5

  /// The link is not valid.
  case invalidToken // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecifiedLinkStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedLinkStatus
    case 1: self = .expiredStrong
    case 2: self = .expiredWeak
    case 3: self = .alreadyUsed
    case 4: self = .authenticated
    case 5: self = .unauthorized
    case 6: self = .invalidToken
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecifiedLinkStatus: return 0
    case .expiredStrong: return 1
    case .expiredWeak: return 2
    case .alreadyUsed: return 3
    case .authenticated: return 4
    case .unauthorized: return 5
    case .invalidToken: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Com_Octopuscommunity_ConfirmLinkStatus] = [
    .unspecifiedLinkStatus,
    .expiredStrong,
    .expiredWeak,
    .alreadyUsed,
    .authenticated,
    .unauthorized,
    .invalidToken,
  ]

}

/// Possible error codes for authentication failures.
public enum Com_Octopuscommunity_ErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// An unknown error occurred.
  case unknownError // = 0

  /// A Magic link connection request exists, but has not been validated by the user yet
  case notAuthenticatedYet // = 1

  /// No magic link connection request found for the given magicLinkId/email combination
  case linkNotFound // = 2

  /// No user related to the magic link connection request found
  case userNotFound // = 3

  /// The magic link connection request has been invalidated by a most recent one
  case invalidLink // = 4

  /// The magic link connection request has expired
  case expiredLink // = 5

  /// The user exists but has been banned
  case userBanned // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownError
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownError
    case 1: self = .notAuthenticatedYet
    case 2: self = .linkNotFound
    case 3: self = .userNotFound
    case 4: self = .invalidLink
    case 5: self = .expiredLink
    case 6: self = .userBanned
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownError: return 0
    case .notAuthenticatedYet: return 1
    case .linkNotFound: return 2
    case .userNotFound: return 3
    case .invalidLink: return 4
    case .expiredLink: return 5
    case .userBanned: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Com_Octopuscommunity_ErrorCode] = [
    .unknownError,
    .notAuthenticatedYet,
    .linkNotFound,
    .userNotFound,
    .invalidLink,
    .expiredLink,
    .userBanned,
  ]

}

/// Request to generate a magic link.
public struct Com_Octopuscommunity_GenerateLinkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The email address to send the magic link to.
  public var email: String = String()

  /// Optional deeplink to include in the magic link.
  public var deeplink: String {
    get {return _deeplink ?? String()}
    set {_deeplink = newValue}
  }
  /// Returns true if `deeplink` has been explicitly set.
  public var hasDeeplink: Bool {return self._deeplink != nil}
  /// Clears the value of `deeplink`. Subsequent reads from it will return its default value.
  public mutating func clearDeeplink() {self._deeplink = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deeplink: String? = nil
}

/// Response after generating a magic link.
public struct Com_Octopuscommunity_GenerateLinkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_GenerateLinkResponse.OneOf_Result? = nil

  /// The generated id for the magic link.
  public var magicLinkID: String {
    get {
      if case .magicLinkID(let v)? = result {return v}
      return String()
    }
    set {result = .magicLinkID(newValue)}
  }

  /// Error details if authentication failed.
  public var error: Com_Octopuscommunity_GenerateLinkResponse.GenerateLinkErrorDetail {
    get {
      if case .error(let v)? = result {return v}
      return Com_Octopuscommunity_GenerateLinkResponse.GenerateLinkErrorDetail()
    }
    set {result = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    /// The generated id for the magic link.
    case magicLinkID(String)
    /// Error details if authentication failed.
    case error(Com_Octopuscommunity_GenerateLinkResponse.GenerateLinkErrorDetail)

  }

  /// Possible error codes for magic link request failures.
  public enum GenerateLinkErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// An unknown error occurred.
    case unknownError // = 0

    /// The user exists but has been banned
    case userBanned // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownError
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownError
      case 1: self = .userBanned
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownError: return 0
      case .userBanned: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Com_Octopuscommunity_GenerateLinkResponse.GenerateLinkErrorCode] = [
      .unknownError,
      .userBanned,
    ]

  }

  /// Detailed error information.
  public struct GenerateLinkErrorDetail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The specific error code.
    public var errorCode: Com_Octopuscommunity_GenerateLinkResponse.GenerateLinkErrorCode = .unknownError

    /// A human-readable error message.
    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Request to confirm a magic link. This message is intentionally empty as the magicLinkId
/// is typically included in the headers of the request.
public struct Com_Octopuscommunity_ConfirmLinkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response after confirming a magic link.
public struct Com_Octopuscommunity_ConfirmLinkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The deeplink to redirect the user to, if any.
  public var deeplink: String {
    get {return _deeplink ?? String()}
    set {_deeplink = newValue}
  }
  /// Returns true if `deeplink` has been explicitly set.
  public var hasDeeplink: Bool {return self._deeplink != nil}
  /// Clears the value of `deeplink`. Subsequent reads from it will return its default value.
  public mutating func clearDeeplink() {self._deeplink = nil}

  /// The user's nickname, if available.
  public var userNickname: String {
    get {return _userNickname ?? String()}
    set {_userNickname = newValue}
  }
  /// Returns true if `userNickname` has been explicitly set.
  public var hasUserNickname: Bool {return self._userNickname != nil}
  /// Clears the value of `userNickname`. Subsequent reads from it will return its default value.
  public mutating func clearUserNickname() {self._userNickname = nil}

  /// The status of the confirmation attempt.
  public var status: Com_Octopuscommunity_ConfirmLinkStatus = .unspecifiedLinkStatus

  ///Only fill when the user is banned to display the reasons
  public var banReasons: [Com_Octopuscommunity_StatusReasonCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deeplink: String? = nil
  fileprivate var _userNickname: String? = nil
}

/// Request to check if a user has been authenticated with a magic link.
public struct Com_Octopuscommunity_IsAuthenticatedRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The magic link id to check.
  public var magicLinkID: String = String()

  /// The email associated with the id.
  public var email: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to an authentication check.
public struct Com_Octopuscommunity_IsAuthenticatedResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_IsAuthenticatedResponse.OneOf_Result? = nil

  /// The response if authentication was successful.
  public var success: Com_Octopuscommunity_AuthenticationSuccess {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_AuthenticationSuccess()
    }
    set {result = .success(newValue)}
  }

  /// Error details if authentication failed.
  public var error: Com_Octopuscommunity_ErrorDetail {
    get {
      if case .error(let v)? = result {return v}
      return Com_Octopuscommunity_ErrorDetail()
    }
    set {result = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    /// The response if authentication was successful.
    case success(Com_Octopuscommunity_AuthenticationSuccess)
    /// Error details if authentication failed.
    case error(Com_Octopuscommunity_ErrorDetail)

  }

  public init() {}
}

///Response after successful authentication
public struct Com_Octopuscommunity_AuthenticationSuccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The jwt related to the user
  public var jwt: String = String()

  /// The user id
  public var userID: String = String()

  /// The profile of the user
  public var profile: Com_Octopuscommunity_PrivateProfile {
    get {return _profile ?? Com_Octopuscommunity_PrivateProfile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {self._profile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _profile: Com_Octopuscommunity_PrivateProfile? = nil
}

/// Detailed error information.
public struct Com_Octopuscommunity_ErrorDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The specific error code.
  public var errorCode: Com_Octopuscommunity_ErrorCode = .unknownError

  /// A human-readable error message.
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.octopuscommunity"

extension Com_Octopuscommunity_ConfirmLinkStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_LINK_STATUS"),
    1: .same(proto: "EXPIRED_STRONG"),
    2: .same(proto: "EXPIRED_WEAK"),
    3: .same(proto: "ALREADY_USED"),
    4: .same(proto: "AUTHENTICATED"),
    5: .same(proto: "UNAUTHORIZED"),
    6: .same(proto: "INVALID_TOKEN"),
  ]
}

extension Com_Octopuscommunity_ErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ERROR"),
    1: .same(proto: "NOT_AUTHENTICATED_YET"),
    2: .same(proto: "LINK_NOT_FOUND"),
    3: .same(proto: "USER_NOT_FOUND"),
    4: .same(proto: "INVALID_LINK"),
    5: .same(proto: "EXPIRED_LINK"),
    6: .same(proto: "USER_BANNED"),
  ]
}

extension Com_Octopuscommunity_GenerateLinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateLinkRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "deeplink"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._deeplink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    try { if let v = self._deeplink {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GenerateLinkRequest, rhs: Com_Octopuscommunity_GenerateLinkRequest) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs._deeplink != rhs._deeplink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GenerateLinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateLinkResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "magicLinkId"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .magicLinkID(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_GenerateLinkResponse.GenerateLinkErrorDetail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .magicLinkID?: try {
      guard case .magicLinkID(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GenerateLinkResponse, rhs: Com_Octopuscommunity_GenerateLinkResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GenerateLinkResponse.GenerateLinkErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ERROR"),
    1: .same(proto: "USER_BANNED"),
  ]
}

extension Com_Octopuscommunity_GenerateLinkResponse.GenerateLinkErrorDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_GenerateLinkResponse.protoMessageName + ".GenerateLinkErrorDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errorCode"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .unknownError {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GenerateLinkResponse.GenerateLinkErrorDetail, rhs: Com_Octopuscommunity_GenerateLinkResponse.GenerateLinkErrorDetail) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ConfirmLinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmLinkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ConfirmLinkRequest, rhs: Com_Octopuscommunity_ConfirmLinkRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ConfirmLinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmLinkResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deeplink"),
    2: .standard(proto: "user_nickname"),
    3: .same(proto: "status"),
    4: .same(proto: "banReasons"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._deeplink) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._userNickname) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.banReasons) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deeplink {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userNickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.status != .unspecifiedLinkStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if !self.banReasons.isEmpty {
      try visitor.visitPackedEnumField(value: self.banReasons, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ConfirmLinkResponse, rhs: Com_Octopuscommunity_ConfirmLinkResponse) -> Bool {
    if lhs._deeplink != rhs._deeplink {return false}
    if lhs._userNickname != rhs._userNickname {return false}
    if lhs.status != rhs.status {return false}
    if lhs.banReasons != rhs.banReasons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_IsAuthenticatedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsAuthenticatedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "magicLinkId"),
    2: .same(proto: "email"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.magicLinkID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.magicLinkID.isEmpty {
      try visitor.visitSingularStringField(value: self.magicLinkID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_IsAuthenticatedRequest, rhs: Com_Octopuscommunity_IsAuthenticatedRequest) -> Bool {
    if lhs.magicLinkID != rhs.magicLinkID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_IsAuthenticatedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsAuthenticatedResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_AuthenticationSuccess?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_ErrorDetail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_IsAuthenticatedResponse, rhs: Com_Octopuscommunity_IsAuthenticatedResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_AuthenticationSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticationSuccess"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
    2: .same(proto: "userId"),
    3: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jwt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.jwt.isEmpty {
      try visitor.visitSingularStringField(value: self.jwt, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_AuthenticationSuccess, rhs: Com_Octopuscommunity_AuthenticationSuccess) -> Bool {
    if lhs.jwt != rhs.jwt {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ErrorDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .unknownError {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetail, rhs: Com_Octopuscommunity_ErrorDetail) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
