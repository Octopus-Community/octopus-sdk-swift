// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: com/octopuscommunity/FeedServiceProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Com_Octopuscommunity_GetRootFeedsInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_GetRootFeedsInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var feedsInfo: [Com_Octopuscommunity_FeedInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_FeedInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var label: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_InitializeFeedWithOctoObjectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var feedID: String = String()

  ///Server can decide to return less than this value
  public var pageSize: Int32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pageSize: Int32? = nil
}

public struct Com_Octopuscommunity_GetFeedWithOctoObjectPageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pageCursor: String = String()

  ///Server can decide to return less than this value
  public var pageSize: Int32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pageSize: Int32? = nil
}

public struct Com_Octopuscommunity_GetFeedWithOctoObjectPageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var feed: [Com_Octopuscommunity_OctoObject] = []

  ///To pass to pageCursor in the next request. `null` if there is no more pages/items
  public var nextPageCursor: String {
    get {return _nextPageCursor ?? String()}
    set {_nextPageCursor = newValue}
  }
  /// Returns true if `nextPageCursor` has been explicitly set.
  public var hasNextPageCursor: Bool {return self._nextPageCursor != nil}
  /// Clears the value of `nextPageCursor`. Subsequent reads from it will return its default value.
  public mutating func clearNextPageCursor() {self._nextPageCursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nextPageCursor: String? = nil
}

public struct Com_Octopuscommunity_InitializeFeedRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var feedID: String = String()

  ///Server can decide to return less than this value
  public var pageSize: Int32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pageSize: Int32? = nil
}

public struct Com_Octopuscommunity_GetFeedPageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pageCursor: String = String()

  ///Server can decide to return less than this value
  public var pageSize: Int32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pageSize: Int32? = nil
}

public struct Com_Octopuscommunity_GetFeedPageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Com_Octopuscommunity_FeedItemInfo] = []

  ///To pass to pageCursor in the next request. `null` if there is no more pages/items
  public var nextPageCursor: String {
    get {return _nextPageCursor ?? String()}
    set {_nextPageCursor = newValue}
  }
  /// Returns true if `nextPageCursor` has been explicitly set.
  public var hasNextPageCursor: Bool {return self._nextPageCursor != nil}
  /// Clears the value of `nextPageCursor`. Subsequent reads from it will return its default value.
  public mutating func clearNextPageCursor() {self._nextPageCursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nextPageCursor: String? = nil
}

public struct Com_Octopuscommunity_FeedItemInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  ///TODO string octoObjecCreatedBy
  public var octoObjectUpdatedAt: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.octopuscommunity"

extension Com_Octopuscommunity_GetRootFeedsInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRootFeedsInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetRootFeedsInfoRequest, rhs: Com_Octopuscommunity_GetRootFeedsInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetRootFeedsInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRootFeedsInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feedsInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.feedsInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.feedsInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feedsInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetRootFeedsInfoResponse, rhs: Com_Octopuscommunity_GetRootFeedsInfoResponse) -> Bool {
    if lhs.feedsInfo != rhs.feedsInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_FeedInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_FeedInfo, rhs: Com_Octopuscommunity_FeedInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_InitializeFeedWithOctoObjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitializeFeedWithOctoObjectRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feedId"),
    2: .same(proto: "pageSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.feedID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.feedID.isEmpty {
      try visitor.visitSingularStringField(value: self.feedID, fieldNumber: 1)
    }
    try { if let v = self._pageSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_InitializeFeedWithOctoObjectRequest, rhs: Com_Octopuscommunity_InitializeFeedWithOctoObjectRequest) -> Bool {
    if lhs.feedID != rhs.feedID {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetFeedWithOctoObjectPageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFeedWithOctoObjectPageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pageCursor"),
    2: .same(proto: "pageSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageCursor) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pageCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.pageCursor, fieldNumber: 1)
    }
    try { if let v = self._pageSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetFeedWithOctoObjectPageRequest, rhs: Com_Octopuscommunity_GetFeedWithOctoObjectPageRequest) -> Bool {
    if lhs.pageCursor != rhs.pageCursor {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetFeedWithOctoObjectPageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFeedWithOctoObjectPageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feed"),
    2: .same(proto: "nextPageCursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.feed) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nextPageCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.feed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feed, fieldNumber: 1)
    }
    try { if let v = self._nextPageCursor {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetFeedWithOctoObjectPageResponse, rhs: Com_Octopuscommunity_GetFeedWithOctoObjectPageResponse) -> Bool {
    if lhs.feed != rhs.feed {return false}
    if lhs._nextPageCursor != rhs._nextPageCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_InitializeFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitializeFeedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feedId"),
    2: .same(proto: "pageSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.feedID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.feedID.isEmpty {
      try visitor.visitSingularStringField(value: self.feedID, fieldNumber: 1)
    }
    try { if let v = self._pageSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_InitializeFeedRequest, rhs: Com_Octopuscommunity_InitializeFeedRequest) -> Bool {
    if lhs.feedID != rhs.feedID {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetFeedPageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFeedPageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pageCursor"),
    2: .same(proto: "pageSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageCursor) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pageCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.pageCursor, fieldNumber: 1)
    }
    try { if let v = self._pageSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetFeedPageRequest, rhs: Com_Octopuscommunity_GetFeedPageRequest) -> Bool {
    if lhs.pageCursor != rhs.pageCursor {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetFeedPageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFeedPageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .same(proto: "nextPageCursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nextPageCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try { if let v = self._nextPageCursor {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetFeedPageResponse, rhs: Com_Octopuscommunity_GetFeedPageResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs._nextPageCursor != rhs._nextPageCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_FeedItemInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedItemInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "octoObjectUpdatedAt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.octoObjectUpdatedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    if self.octoObjectUpdatedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.octoObjectUpdatedAt, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_FeedItemInfo, rhs: Com_Octopuscommunity_FeedItemInfo) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.octoObjectUpdatedAt != rhs.octoObjectUpdatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
