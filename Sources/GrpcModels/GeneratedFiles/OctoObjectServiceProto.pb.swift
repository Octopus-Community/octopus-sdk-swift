// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: com/octopuscommunity/OctoObjectServiceProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Com_Octopuscommunity_RwOctoObject: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parentID: String = String()

  public var content: Com_Octopuscommunity_Content {
    get {return _content ?? Com_Octopuscommunity_Content()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  ///  int64 createdAt;  server side determined by the put logged user
  ///  string createdBy;  server side determined by time of the put request
  /// string id; server side randomly generated
  public var pressedEnterAt: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _content: Com_Octopuscommunity_Content? = nil
}

public struct Com_Octopuscommunity_UpdatePostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var update: Com_Octopuscommunity_UpdatePostRequest.Update {
    get {return _update ?? Com_Octopuscommunity_UpdatePostRequest.Update()}
    set {_update = newValue}
  }
  /// Returns true if `update` has been explicitly set.
  public var hasUpdate: Bool {return self._update != nil}
  /// Clears the value of `update`. Subsequent reads from it will return its default value.
  public mutating func clearUpdate() {self._update = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var topicID: String {
      get {return _topicID ?? String()}
      set {_topicID = newValue}
    }
    /// Returns true if `topicID` has been explicitly set.
    public var hasTopicID: Bool {return self._topicID != nil}
    /// Clears the value of `topicID`. Subsequent reads from it will return its default value.
    public mutating func clearTopicID() {self._topicID = nil}

    public var postContent: Com_Octopuscommunity_Post {
      get {return _postContent ?? Com_Octopuscommunity_Post()}
      set {_postContent = newValue}
    }
    /// Returns true if `postContent` has been explicitly set.
    public var hasPostContent: Bool {return self._postContent != nil}
    /// Clears the value of `postContent`. Subsequent reads from it will return its default value.
    public mutating func clearPostContent() {self._postContent = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _topicID: String? = nil
    fileprivate var _postContent: Com_Octopuscommunity_Post? = nil
  }

  public init() {}

  fileprivate var _update: Com_Octopuscommunity_UpdatePostRequest.Update? = nil
}

public struct Com_Octopuscommunity_UpdatePostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_UpdatePostResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_UpdatePostResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_UpdatePostResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_UpdatePostResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_UpdatePostResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_UpdatePostResponse.Success)
    case fail(Com_Octopuscommunity_UpdatePostResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var post: Com_Octopuscommunity_OctoObject {
      get {return _post ?? Com_Octopuscommunity_OctoObject()}
      set {_post = newValue}
    }
    /// Returns true if `post` has been explicitly set.
    public var hasPost: Bool {return self._post != nil}
    /// Clears the value of `post`. Subsequent reads from it will return its default value.
    public mutating func clearPost() {self._post = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _post: Com_Octopuscommunity_OctoObject? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_UpdatePostResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var field: Com_Octopuscommunity_UpdatePostResponse.Error.Field {
      get {return _field ?? .unknown}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var details: Com_Octopuscommunity_UpdatePostResponse.Error.OneOf_Details? = nil

    public var missingText: Com_Octopuscommunity_ErrorDetails.MissingText {
      get {
        if case .missingText(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingText()
      }
      set {details = .missingText(newValue)}
    }

    public var bannedWordUsed: Com_Octopuscommunity_ErrorDetails.BannedWordUsed {
      get {
        if case .bannedWordUsed(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BannedWordUsed()
      }
      set {details = .bannedWordUsed(newValue)}
    }

    public var maxCharLimitReached: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached {
      get {
        if case .maxCharLimitReached(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached()
      }
      set {details = .maxCharLimitReached(newValue)}
    }

    public var emptyFile: Com_Octopuscommunity_ErrorDetails.EmptyFile {
      get {
        if case .emptyFile(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyFile()
      }
      set {details = .emptyFile(newValue)}
    }

    public var fileSizeTooBig: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig {
      get {
        if case .fileSizeTooBig(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.FileSizeTooBig()
      }
      set {details = .fileSizeTooBig(newValue)}
    }

    public var badFileFormat: Com_Octopuscommunity_ErrorDetails.BadFileFormat {
      get {
        if case .badFileFormat(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BadFileFormat()
      }
      set {details = .badFileFormat(newValue)}
    }

    public var uploadIssue: Com_Octopuscommunity_ErrorDetails.UploadIssue {
      get {
        if case .uploadIssue(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.UploadIssue()
      }
      set {details = .uploadIssue(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case missingText(Com_Octopuscommunity_ErrorDetails.MissingText)
      case bannedWordUsed(Com_Octopuscommunity_ErrorDetails.BannedWordUsed)
      case maxCharLimitReached(Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached)
      case emptyFile(Com_Octopuscommunity_ErrorDetails.EmptyFile)
      case fileSizeTooBig(Com_Octopuscommunity_ErrorDetails.FileSizeTooBig)
      case badFileFormat(Com_Octopuscommunity_ErrorDetails.BadFileFormat)
      case uploadIssue(Com_Octopuscommunity_ErrorDetails.UploadIssue)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0

      ///MissingText, BannedWordUsed, MaxCharLimitReached
      case contentText // = 2

      /// field 3 was "CONTENT_TEXT = 3;", now removed
      case contentFile // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 2: self = .contentText
        case 4: self = .contentFile
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contentText: return 2
        case .contentFile: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_UpdatePostResponse.Error.Field] = [
        .unknown,
        .contentText,
        .contentFile,
      ]

    }

    public init() {}

    fileprivate var _field: Com_Octopuscommunity_UpdatePostResponse.Error.Field? = nil
  }

  public init() {}
}

public struct Com_Octopuscommunity_GetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var fetchObject: Bool = false

  public var fetchRequesterCtx: Bool = false

  public var fetchAggregate: Bool = false

  public var registerView: Bool {
    get {return _registerView ?? false}
    set {_registerView = newValue}
  }
  /// Returns true if `registerView` has been explicitly set.
  public var hasRegisterView: Bool {return self._registerView != nil}
  /// Clears the value of `registerView`. Subsequent reads from it will return its default value.
  public mutating func clearRegisterView() {self._registerView = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _registerView: Bool? = nil
}

public struct Com_Octopuscommunity_GetResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String {
    get {return _storage._octoObjectID}
    set {_uniqueStorage()._octoObjectID = newValue}
  }

  public var octoObject: Com_Octopuscommunity_OctoObject {
    get {return _storage._octoObject ?? Com_Octopuscommunity_OctoObject()}
    set {_uniqueStorage()._octoObject = newValue}
  }
  /// Returns true if `octoObject` has been explicitly set.
  public var hasOctoObject: Bool {return _storage._octoObject != nil}
  /// Clears the value of `octoObject`. Subsequent reads from it will return its default value.
  public mutating func clearOctoObject() {_uniqueStorage()._octoObject = nil}

  public var aggregate: Com_Octopuscommunity_Aggregate {
    get {return _storage._aggregate ?? Com_Octopuscommunity_Aggregate()}
    set {_uniqueStorage()._aggregate = newValue}
  }
  /// Returns true if `aggregate` has been explicitly set.
  public var hasAggregate: Bool {return _storage._aggregate != nil}
  /// Clears the value of `aggregate`. Subsequent reads from it will return its default value.
  public mutating func clearAggregate() {_uniqueStorage()._aggregate = nil}

  public var requesterCtx: Com_Octopuscommunity_RequesterCtx {
    get {return _storage._requesterCtx ?? Com_Octopuscommunity_RequesterCtx()}
    set {_uniqueStorage()._requesterCtx = newValue}
  }
  /// Returns true if `requesterCtx` has been explicitly set.
  public var hasRequesterCtx: Bool {return _storage._requesterCtx != nil}
  /// Clears the value of `requesterCtx`. Subsequent reads from it will return its default value.
  public mutating func clearRequesterCtx() {_uniqueStorage()._requesterCtx = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Com_Octopuscommunity_GetBatchRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Com_Octopuscommunity_GetRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_GetBatchResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responses: [Com_Octopuscommunity_GetResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_PutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObject: Com_Octopuscommunity_RwOctoObject {
    get {return _octoObject ?? Com_Octopuscommunity_RwOctoObject()}
    set {_octoObject = newValue}
  }
  /// Returns true if `octoObject` has been explicitly set.
  public var hasOctoObject: Bool {return self._octoObject != nil}
  /// Clears the value of `octoObject`. Subsequent reads from it will return its default value.
  public mutating func clearOctoObject() {self._octoObject = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _octoObject: Com_Octopuscommunity_RwOctoObject? = nil
}

public struct Com_Octopuscommunity_PutCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_PutCommentResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_PutCommentResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_PutCommentResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_PutCommentResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_PutCommentResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_PutCommentResponse.Success)
    case fail(Com_Octopuscommunity_PutCommentResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var comment: Com_Octopuscommunity_OctoObject {
      get {return _comment ?? Com_Octopuscommunity_OctoObject()}
      set {_comment = newValue}
    }
    /// Returns true if `comment` has been explicitly set.
    public var hasComment: Bool {return self._comment != nil}
    /// Clears the value of `comment`. Subsequent reads from it will return its default value.
    public mutating func clearComment() {self._comment = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _comment: Com_Octopuscommunity_OctoObject? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_PutCommentResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var field: Com_Octopuscommunity_PutCommentResponse.Error.Field {
      get {return _field ?? .unknown}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var details: Com_Octopuscommunity_PutCommentResponse.Error.OneOf_Details? = nil

    public var missingParent: Com_Octopuscommunity_ErrorDetails.MissingParent {
      get {
        if case .missingParent(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingParent()
      }
      set {details = .missingParent(newValue)}
    }

    public var bannedWordUsed: Com_Octopuscommunity_ErrorDetails.BannedWordUsed {
      get {
        if case .bannedWordUsed(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BannedWordUsed()
      }
      set {details = .bannedWordUsed(newValue)}
    }

    public var maxCharLimitReached: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached {
      get {
        if case .maxCharLimitReached(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached()
      }
      set {details = .maxCharLimitReached(newValue)}
    }

    public var emptyFile: Com_Octopuscommunity_ErrorDetails.EmptyFile {
      get {
        if case .emptyFile(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyFile()
      }
      set {details = .emptyFile(newValue)}
    }

    public var fileSizeTooBig: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig {
      get {
        if case .fileSizeTooBig(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.FileSizeTooBig()
      }
      set {details = .fileSizeTooBig(newValue)}
    }

    public var badFileFormat: Com_Octopuscommunity_ErrorDetails.BadFileFormat {
      get {
        if case .badFileFormat(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BadFileFormat()
      }
      set {details = .badFileFormat(newValue)}
    }

    public var uploadIssue: Com_Octopuscommunity_ErrorDetails.UploadIssue {
      get {
        if case .uploadIssue(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.UploadIssue()
      }
      set {details = .uploadIssue(newValue)}
    }

    public var emptyPublication: Com_Octopuscommunity_ErrorDetails.EmptyPublication {
      get {
        if case .emptyPublication(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyPublication()
      }
      set {details = .emptyPublication(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case missingParent(Com_Octopuscommunity_ErrorDetails.MissingParent)
      case bannedWordUsed(Com_Octopuscommunity_ErrorDetails.BannedWordUsed)
      case maxCharLimitReached(Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached)
      case emptyFile(Com_Octopuscommunity_ErrorDetails.EmptyFile)
      case fileSizeTooBig(Com_Octopuscommunity_ErrorDetails.FileSizeTooBig)
      case badFileFormat(Com_Octopuscommunity_ErrorDetails.BadFileFormat)
      case uploadIssue(Com_Octopuscommunity_ErrorDetails.UploadIssue)
      case emptyPublication(Com_Octopuscommunity_ErrorDetails.EmptyPublication)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0

      ///MissingParent
      case contentParent // = 1

      ///BannedWordUsed, MaxCharLimitReached
      case contentText // = 2

      ///EmptyFile, FileSizeTooBig, BadFileFormat, UploadIssue
      case contentFile // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contentParent
        case 2: self = .contentText
        case 3: self = .contentFile
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contentParent: return 1
        case .contentText: return 2
        case .contentFile: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_PutCommentResponse.Error.Field] = [
        .unknown,
        .contentParent,
        .contentText,
        .contentFile,
      ]

    }

    public init() {}

    fileprivate var _field: Com_Octopuscommunity_PutCommentResponse.Error.Field? = nil
  }

  public init() {}
}

public struct Com_Octopuscommunity_PutLikeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_PutLikeResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_PutLikeResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_PutLikeResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_PutLikeResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_PutLikeResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_PutLikeResponse.Success)
    case fail(Com_Octopuscommunity_PutLikeResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var like: Com_Octopuscommunity_OctoObject {
      get {return _like ?? Com_Octopuscommunity_OctoObject()}
      set {_like = newValue}
    }
    /// Returns true if `like` has been explicitly set.
    public var hasLike: Bool {return self._like != nil}
    /// Clears the value of `like`. Subsequent reads from it will return its default value.
    public mutating func clearLike() {self._like = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _like: Com_Octopuscommunity_OctoObject? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_PutLikeResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var field: Com_Octopuscommunity_PutLikeResponse.Error.Field {
      get {return _field ?? .unknown}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var details: Com_Octopuscommunity_PutLikeResponse.Error.OneOf_Details? = nil

    public var missingParent: Com_Octopuscommunity_ErrorDetails.MissingParent {
      get {
        if case .missingParent(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingParent()
      }
      set {details = .missingParent(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case missingParent(Com_Octopuscommunity_ErrorDetails.MissingParent)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0

      ///MissingParent
      case contentParent // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contentParent
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contentParent: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_PutLikeResponse.Error.Field] = [
        .unknown,
        .contentParent,
      ]

    }

    public init() {}

    fileprivate var _field: Com_Octopuscommunity_PutLikeResponse.Error.Field? = nil
  }

  public init() {}
}

public struct Com_Octopuscommunity_PutPostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Com_Octopuscommunity_PutPostResponse.OneOf_Result? = nil

  public var success: Com_Octopuscommunity_PutPostResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Com_Octopuscommunity_PutPostResponse.Success()
    }
    set {result = .success(newValue)}
  }

  public var fail: Com_Octopuscommunity_PutPostResponse.Fail {
    get {
      if case .fail(let v)? = result {return v}
      return Com_Octopuscommunity_PutPostResponse.Fail()
    }
    set {result = .fail(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case success(Com_Octopuscommunity_PutPostResponse.Success)
    case fail(Com_Octopuscommunity_PutPostResponse.Fail)

  }

  public struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var post: Com_Octopuscommunity_OctoObject {
      get {return _post ?? Com_Octopuscommunity_OctoObject()}
      set {_post = newValue}
    }
    /// Returns true if `post` has been explicitly set.
    public var hasPost: Bool {return self._post != nil}
    /// Clears the value of `post`. Subsequent reads from it will return its default value.
    public mutating func clearPost() {self._post = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _post: Com_Octopuscommunity_OctoObject? = nil
  }

  public struct Fail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errors: [Com_Octopuscommunity_PutPostResponse.Error] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String = String()

    public var field: Com_Octopuscommunity_PutPostResponse.Error.Field {
      get {return _field ?? .unknown}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    public var details: Com_Octopuscommunity_PutPostResponse.Error.OneOf_Details? = nil

    public var missingParent: Com_Octopuscommunity_ErrorDetails.MissingParent {
      get {
        if case .missingParent(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingParent()
      }
      set {details = .missingParent(newValue)}
    }

    public var missingText: Com_Octopuscommunity_ErrorDetails.MissingText {
      get {
        if case .missingText(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MissingText()
      }
      set {details = .missingText(newValue)}
    }

    public var bannedWordUsed: Com_Octopuscommunity_ErrorDetails.BannedWordUsed {
      get {
        if case .bannedWordUsed(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BannedWordUsed()
      }
      set {details = .bannedWordUsed(newValue)}
    }

    public var maxCharLimitReached: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached {
      get {
        if case .maxCharLimitReached(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached()
      }
      set {details = .maxCharLimitReached(newValue)}
    }

    public var emptyFile: Com_Octopuscommunity_ErrorDetails.EmptyFile {
      get {
        if case .emptyFile(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.EmptyFile()
      }
      set {details = .emptyFile(newValue)}
    }

    public var fileSizeTooBig: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig {
      get {
        if case .fileSizeTooBig(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.FileSizeTooBig()
      }
      set {details = .fileSizeTooBig(newValue)}
    }

    public var badFileFormat: Com_Octopuscommunity_ErrorDetails.BadFileFormat {
      get {
        if case .badFileFormat(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.BadFileFormat()
      }
      set {details = .badFileFormat(newValue)}
    }

    public var uploadIssue: Com_Octopuscommunity_ErrorDetails.UploadIssue {
      get {
        if case .uploadIssue(let v)? = details {return v}
        return Com_Octopuscommunity_ErrorDetails.UploadIssue()
      }
      set {details = .uploadIssue(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Details: Equatable, Sendable {
      case missingParent(Com_Octopuscommunity_ErrorDetails.MissingParent)
      case missingText(Com_Octopuscommunity_ErrorDetails.MissingText)
      case bannedWordUsed(Com_Octopuscommunity_ErrorDetails.BannedWordUsed)
      case maxCharLimitReached(Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached)
      case emptyFile(Com_Octopuscommunity_ErrorDetails.EmptyFile)
      case fileSizeTooBig(Com_Octopuscommunity_ErrorDetails.FileSizeTooBig)
      case badFileFormat(Com_Octopuscommunity_ErrorDetails.BadFileFormat)
      case uploadIssue(Com_Octopuscommunity_ErrorDetails.UploadIssue)

    }

    public enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0

      ///MissingParent
      case contentParent // = 1

      ///MissingText, BannedWordUsed, MaxCharLimitReached
      case contentText // = 2

      /// field 3 was "CONTENT_TEXT = 3;", now removed
      case contentFile // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contentParent
        case 2: self = .contentText
        case 4: self = .contentFile
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contentParent: return 1
        case .contentText: return 2
        case .contentFile: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Com_Octopuscommunity_PutPostResponse.Error.Field] = [
        .unknown,
        .contentParent,
        .contentText,
        .contentFile,
      ]

    }

    public init() {}

    fileprivate var _field: Com_Octopuscommunity_PutPostResponse.Error.Field? = nil
  }

  public init() {}
}

///Error messages on Put
public struct Com_Octopuscommunity_ErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct MissingParent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MaxCharLimitReached: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BannedWordUsed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var words: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MissingText: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct EmptyFile: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct FileSizeTooBig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BadFileFormat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct UploadIssue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct EmptyPublication: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

///Implicit community field determined from API_KEY or hard coded for V0.1
public struct Com_Octopuscommunity_GetTopicsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_GetTopicsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topics: [Com_Octopuscommunity_OctoObject] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeletePostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeletePostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeleteLikeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeleteLikeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeleteCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_DeleteCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ModeratePostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var reasonCodes: [Com_Octopuscommunity_StatusReasonCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ModeratePostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ModerateCommentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var reasonCodes: [Com_Octopuscommunity_StatusReasonCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ModerateCommentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Octopuscommunity_ReportContentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var octoObjectID: String = String()

  public var reasonCodes: [Com_Octopuscommunity_ReportReasonCode] = []

  public var customReason: String {
    get {return _customReason ?? String()}
    set {_customReason = newValue}
  }
  /// Returns true if `customReason` has been explicitly set.
  public var hasCustomReason: Bool {return self._customReason != nil}
  /// Clears the value of `customReason`. Subsequent reads from it will return its default value.
  public mutating func clearCustomReason() {self._customReason = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _customReason: String? = nil
}

public struct Com_Octopuscommunity_ReportContentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.octopuscommunity"

extension Com_Octopuscommunity_RwOctoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RwOctoObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parentId"),
    2: .same(proto: "content"),
    3: .same(proto: "pressedEnterAt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.pressedEnterAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parentID.isEmpty {
      try visitor.visitSingularStringField(value: self.parentID, fieldNumber: 1)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pressedEnterAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.pressedEnterAt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_RwOctoObject, rhs: Com_Octopuscommunity_RwOctoObject) -> Bool {
    if lhs.parentID != rhs.parentID {return false}
    if lhs._content != rhs._content {return false}
    if lhs.pressedEnterAt != rhs.pressedEnterAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._update) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try { if let v = self._update {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostRequest, rhs: Com_Octopuscommunity_UpdatePostRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs._update != rhs._update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostRequest.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdatePostRequest.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicId"),
    2: .same(proto: "postContent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._topicID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._postContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topicID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._postContent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostRequest.Update, rhs: Com_Octopuscommunity_UpdatePostRequest.Update) -> Bool {
    if lhs._topicID != rhs._topicID {return false}
    if lhs._postContent != rhs._postContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePostResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_UpdatePostResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_UpdatePostResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostResponse, rhs: Com_Octopuscommunity_UpdatePostResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdatePostResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "post"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._post) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._post {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostResponse.Success, rhs: Com_Octopuscommunity_UpdatePostResponse.Success) -> Bool {
    if lhs._post != rhs._post {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdatePostResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostResponse.Fail, rhs: Com_Octopuscommunity_UpdatePostResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_UpdatePostResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    102: .same(proto: "missingText"),
    103: .same(proto: "bannedWordUsed"),
    104: .same(proto: "maxCharLimitReached"),
    105: .same(proto: "emptyFile"),
    106: .same(proto: "fileSizeTooBig"),
    107: .same(proto: "badFileFormat"),
    108: .same(proto: "uploadIssue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._field) }()
      case 102: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingText?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingText(v)
        }
      }()
      case 103: try {
        var v: Com_Octopuscommunity_ErrorDetails.BannedWordUsed?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .bannedWordUsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .bannedWordUsed(v)
        }
      }()
      case 104: try {
        var v: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .maxCharLimitReached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .maxCharLimitReached(v)
        }
      }()
      case 105: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyFile?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyFile(v)
        }
      }()
      case 106: try {
        var v: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .fileSizeTooBig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .fileSizeTooBig(v)
        }
      }()
      case 107: try {
        var v: Com_Octopuscommunity_ErrorDetails.BadFileFormat?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badFileFormat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badFileFormat(v)
        }
      }()
      case 108: try {
        var v: Com_Octopuscommunity_ErrorDetails.UploadIssue?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .uploadIssue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .uploadIssue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._field {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    switch self.details {
    case .missingText?: try {
      guard case .missingText(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .bannedWordUsed?: try {
      guard case .bannedWordUsed(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .maxCharLimitReached?: try {
      guard case .maxCharLimitReached(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .emptyFile?: try {
      guard case .emptyFile(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .fileSizeTooBig?: try {
      guard case .fileSizeTooBig(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .badFileFormat?: try {
      guard case .badFileFormat(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .uploadIssue?: try {
      guard case .uploadIssue(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_UpdatePostResponse.Error, rhs: Com_Octopuscommunity_UpdatePostResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_UpdatePostResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    2: .same(proto: "CONTENT_TEXT"),
    4: .same(proto: "CONTENT_FILE"),
  ]
}

extension Com_Octopuscommunity_GetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "fetchObject"),
    3: .same(proto: "fetchRequesterCtx"),
    4: .same(proto: "fetchAggregate"),
    6: .same(proto: "registerView"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.fetchObject) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.fetchRequesterCtx) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.fetchAggregate) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._registerView) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    if self.fetchObject != false {
      try visitor.visitSingularBoolField(value: self.fetchObject, fieldNumber: 2)
    }
    if self.fetchRequesterCtx != false {
      try visitor.visitSingularBoolField(value: self.fetchRequesterCtx, fieldNumber: 3)
    }
    if self.fetchAggregate != false {
      try visitor.visitSingularBoolField(value: self.fetchAggregate, fieldNumber: 4)
    }
    try { if let v = self._registerView {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetRequest, rhs: Com_Octopuscommunity_GetRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.fetchObject != rhs.fetchObject {return false}
    if lhs.fetchRequesterCtx != rhs.fetchRequesterCtx {return false}
    if lhs.fetchAggregate != rhs.fetchAggregate {return false}
    if lhs._registerView != rhs._registerView {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "octoObject"),
    3: .same(proto: "aggregate"),
    4: .same(proto: "requesterCtx"),
  ]

  fileprivate class _StorageClass {
    var _octoObjectID: String = String()
    var _octoObject: Com_Octopuscommunity_OctoObject? = nil
    var _aggregate: Com_Octopuscommunity_Aggregate? = nil
    var _requesterCtx: Com_Octopuscommunity_RequesterCtx? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _octoObjectID = source._octoObjectID
      _octoObject = source._octoObject
      _aggregate = source._aggregate
      _requesterCtx = source._requesterCtx
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._octoObjectID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._octoObject) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._aggregate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._requesterCtx) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._octoObjectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._octoObjectID, fieldNumber: 1)
      }
      try { if let v = _storage._octoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._aggregate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._requesterCtx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetResponse, rhs: Com_Octopuscommunity_GetResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._octoObjectID != rhs_storage._octoObjectID {return false}
        if _storage._octoObject != rhs_storage._octoObject {return false}
        if _storage._aggregate != rhs_storage._aggregate {return false}
        if _storage._requesterCtx != rhs_storage._requesterCtx {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetBatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBatchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetBatchRequest, rhs: Com_Octopuscommunity_GetBatchRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBatchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "responses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetBatchResponse, rhs: Com_Octopuscommunity_GetBatchResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObject"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._octoObject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._octoObject {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutRequest, rhs: Com_Octopuscommunity_PutRequest) -> Bool {
    if lhs._octoObject != rhs._octoObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutCommentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_PutCommentResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_PutCommentResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutCommentResponse, rhs: Com_Octopuscommunity_PutCommentResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutCommentResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutCommentResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "comment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._comment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._comment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutCommentResponse.Success, rhs: Com_Octopuscommunity_PutCommentResponse.Success) -> Bool {
    if lhs._comment != rhs._comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutCommentResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutCommentResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutCommentResponse.Fail, rhs: Com_Octopuscommunity_PutCommentResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutCommentResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutCommentResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    101: .same(proto: "missingParent"),
    102: .same(proto: "bannedWordUsed"),
    103: .same(proto: "maxCharLimitReached"),
    104: .same(proto: "emptyFile"),
    105: .same(proto: "fileSizeTooBig"),
    106: .same(proto: "badFileFormat"),
    107: .same(proto: "uploadIssue"),
    108: .same(proto: "emptyPublication"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._field) }()
      case 101: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingParent?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingParent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingParent(v)
        }
      }()
      case 102: try {
        var v: Com_Octopuscommunity_ErrorDetails.BannedWordUsed?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .bannedWordUsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .bannedWordUsed(v)
        }
      }()
      case 103: try {
        var v: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .maxCharLimitReached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .maxCharLimitReached(v)
        }
      }()
      case 104: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyFile?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyFile(v)
        }
      }()
      case 105: try {
        var v: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .fileSizeTooBig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .fileSizeTooBig(v)
        }
      }()
      case 106: try {
        var v: Com_Octopuscommunity_ErrorDetails.BadFileFormat?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badFileFormat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badFileFormat(v)
        }
      }()
      case 107: try {
        var v: Com_Octopuscommunity_ErrorDetails.UploadIssue?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .uploadIssue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .uploadIssue(v)
        }
      }()
      case 108: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyPublication?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyPublication(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyPublication(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._field {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    switch self.details {
    case .missingParent?: try {
      guard case .missingParent(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .bannedWordUsed?: try {
      guard case .bannedWordUsed(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .maxCharLimitReached?: try {
      guard case .maxCharLimitReached(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .emptyFile?: try {
      guard case .emptyFile(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .fileSizeTooBig?: try {
      guard case .fileSizeTooBig(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .badFileFormat?: try {
      guard case .badFileFormat(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .uploadIssue?: try {
      guard case .uploadIssue(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .emptyPublication?: try {
      guard case .emptyPublication(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutCommentResponse.Error, rhs: Com_Octopuscommunity_PutCommentResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutCommentResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTENT_PARENT"),
    2: .same(proto: "CONTENT_TEXT"),
    3: .same(proto: "CONTENT_FILE"),
  ]
}

extension Com_Octopuscommunity_PutLikeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutLikeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_PutLikeResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_PutLikeResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutLikeResponse, rhs: Com_Octopuscommunity_PutLikeResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutLikeResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutLikeResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "like"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._like) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._like {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutLikeResponse.Success, rhs: Com_Octopuscommunity_PutLikeResponse.Success) -> Bool {
    if lhs._like != rhs._like {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutLikeResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutLikeResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutLikeResponse.Fail, rhs: Com_Octopuscommunity_PutLikeResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutLikeResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutLikeResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    101: .same(proto: "missingParent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._field) }()
      case 101: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingParent?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingParent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingParent(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._field {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if case .missingParent(let v)? = self.details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutLikeResponse.Error, rhs: Com_Octopuscommunity_PutLikeResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutLikeResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTENT_PARENT"),
  ]
}

extension Com_Octopuscommunity_PutPostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutPostResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "fail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Octopuscommunity_PutPostResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Com_Octopuscommunity_PutPostResponse.Fail?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .fail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .fail(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fail?: try {
      guard case .fail(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPostResponse, rhs: Com_Octopuscommunity_PutPostResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPostResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutPostResponse.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "post"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._post) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._post {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPostResponse.Success, rhs: Com_Octopuscommunity_PutPostResponse.Success) -> Bool {
    if lhs._post != rhs._post {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPostResponse.Fail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutPostResponse.protoMessageName + ".Fail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPostResponse.Fail, rhs: Com_Octopuscommunity_PutPostResponse.Fail) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPostResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_PutPostResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "field"),
    101: .same(proto: "missingParent"),
    102: .same(proto: "missingText"),
    103: .same(proto: "bannedWordUsed"),
    104: .same(proto: "maxCharLimitReached"),
    105: .same(proto: "emptyFile"),
    106: .same(proto: "fileSizeTooBig"),
    107: .same(proto: "badFileFormat"),
    108: .same(proto: "uploadIssue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._field) }()
      case 101: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingParent?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingParent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingParent(v)
        }
      }()
      case 102: try {
        var v: Com_Octopuscommunity_ErrorDetails.MissingText?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .missingText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .missingText(v)
        }
      }()
      case 103: try {
        var v: Com_Octopuscommunity_ErrorDetails.BannedWordUsed?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .bannedWordUsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .bannedWordUsed(v)
        }
      }()
      case 104: try {
        var v: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .maxCharLimitReached(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .maxCharLimitReached(v)
        }
      }()
      case 105: try {
        var v: Com_Octopuscommunity_ErrorDetails.EmptyFile?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .emptyFile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .emptyFile(v)
        }
      }()
      case 106: try {
        var v: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .fileSizeTooBig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .fileSizeTooBig(v)
        }
      }()
      case 107: try {
        var v: Com_Octopuscommunity_ErrorDetails.BadFileFormat?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .badFileFormat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .badFileFormat(v)
        }
      }()
      case 108: try {
        var v: Com_Octopuscommunity_ErrorDetails.UploadIssue?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .uploadIssue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .uploadIssue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._field {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    switch self.details {
    case .missingParent?: try {
      guard case .missingParent(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .missingText?: try {
      guard case .missingText(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .bannedWordUsed?: try {
      guard case .bannedWordUsed(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .maxCharLimitReached?: try {
      guard case .maxCharLimitReached(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .emptyFile?: try {
      guard case .emptyFile(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .fileSizeTooBig?: try {
      guard case .fileSizeTooBig(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .badFileFormat?: try {
      guard case .badFileFormat(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .uploadIssue?: try {
      guard case .uploadIssue(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_PutPostResponse.Error, rhs: Com_Octopuscommunity_PutPostResponse.Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_PutPostResponse.Error.Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTENT_PARENT"),
    2: .same(proto: "CONTENT_TEXT"),
    4: .same(proto: "CONTENT_FILE"),
  ]
}

extension Com_Octopuscommunity_ErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorDetails"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetails, rhs: Com_Octopuscommunity_ErrorDetails) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ErrorDetails.MissingParent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ErrorDetails.protoMessageName + ".MissingParent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetails.MissingParent, rhs: Com_Octopuscommunity_ErrorDetails.MissingParent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ErrorDetails.protoMessageName + ".MaxCharLimitReached"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached, rhs: Com_Octopuscommunity_ErrorDetails.MaxCharLimitReached) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ErrorDetails.BannedWordUsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ErrorDetails.protoMessageName + ".BannedWordUsed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "words"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.words) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.words.isEmpty {
      try visitor.visitRepeatedStringField(value: self.words, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetails.BannedWordUsed, rhs: Com_Octopuscommunity_ErrorDetails.BannedWordUsed) -> Bool {
    if lhs.words != rhs.words {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ErrorDetails.MissingText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ErrorDetails.protoMessageName + ".MissingText"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetails.MissingText, rhs: Com_Octopuscommunity_ErrorDetails.MissingText) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ErrorDetails.EmptyFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ErrorDetails.protoMessageName + ".EmptyFile"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetails.EmptyFile, rhs: Com_Octopuscommunity_ErrorDetails.EmptyFile) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ErrorDetails.FileSizeTooBig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ErrorDetails.protoMessageName + ".FileSizeTooBig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig, rhs: Com_Octopuscommunity_ErrorDetails.FileSizeTooBig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ErrorDetails.BadFileFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ErrorDetails.protoMessageName + ".BadFileFormat"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetails.BadFileFormat, rhs: Com_Octopuscommunity_ErrorDetails.BadFileFormat) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ErrorDetails.UploadIssue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ErrorDetails.protoMessageName + ".UploadIssue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetails.UploadIssue, rhs: Com_Octopuscommunity_ErrorDetails.UploadIssue) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ErrorDetails.EmptyPublication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Octopuscommunity_ErrorDetails.protoMessageName + ".EmptyPublication"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ErrorDetails.EmptyPublication, rhs: Com_Octopuscommunity_ErrorDetails.EmptyPublication) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetTopicsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTopicsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetTopicsRequest, rhs: Com_Octopuscommunity_GetTopicsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_GetTopicsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTopicsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_GetTopicsResponse, rhs: Com_Octopuscommunity_GetTopicsResponse) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeletePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeletePostRequest, rhs: Com_Octopuscommunity_DeletePostRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeletePostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePostResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeletePostResponse, rhs: Com_Octopuscommunity_DeletePostResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteLikeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteLikeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteLikeRequest, rhs: Com_Octopuscommunity_DeleteLikeRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteLikeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteLikeResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteLikeResponse, rhs: Com_Octopuscommunity_DeleteLikeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCommentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteCommentRequest, rhs: Com_Octopuscommunity_DeleteCommentRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_DeleteCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_DeleteCommentResponse, rhs: Com_Octopuscommunity_DeleteCommentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ModeratePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModeratePostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "reasonCodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reasonCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    if !self.reasonCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasonCodes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ModeratePostRequest, rhs: Com_Octopuscommunity_ModeratePostRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.reasonCodes != rhs.reasonCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ModeratePostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModeratePostResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ModeratePostResponse, rhs: Com_Octopuscommunity_ModeratePostResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ModerateCommentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModerateCommentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "reasonCodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reasonCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    if !self.reasonCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasonCodes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ModerateCommentRequest, rhs: Com_Octopuscommunity_ModerateCommentRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.reasonCodes != rhs.reasonCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ModerateCommentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModerateCommentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ModerateCommentResponse, rhs: Com_Octopuscommunity_ModerateCommentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ReportContentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportContentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "octoObjectId"),
    2: .same(proto: "reasonCodes"),
    3: .same(proto: "customReason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.octoObjectID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reasonCodes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._customReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.octoObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.octoObjectID, fieldNumber: 1)
    }
    if !self.reasonCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasonCodes, fieldNumber: 2)
    }
    try { if let v = self._customReason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ReportContentRequest, rhs: Com_Octopuscommunity_ReportContentRequest) -> Bool {
    if lhs.octoObjectID != rhs.octoObjectID {return false}
    if lhs.reasonCodes != rhs.reasonCodes {return false}
    if lhs._customReason != rhs._customReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Octopuscommunity_ReportContentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportContentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Octopuscommunity_ReportContentResponse, rhs: Com_Octopuscommunity_ReportContentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
